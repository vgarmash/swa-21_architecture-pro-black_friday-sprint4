# Задание 9. Настройка чтения с реплик и консистентность

## Введение

При работе с MongoDB в режиме репликации важно правильно распределить операции чтения между primary и secondary репликами. Это позволяет:
- Снизить нагрузку на primary реплику
- Повысить общую пропускную способность системы
- Обеспечить требуемый уровень консистентности данных

Однако чтение с secondary реплик имеет риск получения устаревших данных из-за задержки репликации (replication lag). Поэтому необходимо тщательно анализировать каждую операцию с точки зрения требований к консистентности.

## 1. Анализ операций чтения по коллекциям

### 1.1. Коллекция `products`

| Операция | Primary/Secondary | Допустимая задержка | Обоснование |
|----------|-------------------|---------------------|-------------|
| **Поиск товаров по категориям** | Secondary | 5-10 секунд | - Каталог товаров обновляется редко<br>- Небольшая задержка не критична для UX<br>- Позволяет разгрузить primary |
| **Фильтрация по цене** | Secondary | 5-10 секунд | - Цены обновляются нечасто (обычно по расписанию)<br>- Задержка в несколько секунд приемлема |
| **Просмотр карточки товара** | Secondary | 5-10 секунд | - Информация о товаре меняется редко<br>- Пользователь не заметит задержку в 5-10 секунд |
| **Проверка наличия товара перед добавлением в корзину** | Primary | 0 секунд | - **Критично**: необходимо актуальное значение остатков<br>- Риск добавления в корзину недоступного товара<br>- Может привести к негативному UX при оформлении заказа |
| **Проверка наличия при оформлении заказа** | Primary | 0 секунд | - **Критично**: финальная проверка перед списанием<br>- Предотвращает продажу недоступного товара<br>- Бизнес-критичная операция |
| **Получение остатков для аналитики** | Secondary | 30-60 секунд | - Аналитические отчеты не требуют real-time данных<br>- Можно использовать данные с задержкой |

### 1.2. Коллекция `orders`

| Операция | Primary/Secondary | Допустимая задержка | Обоснование |
|----------|-------------------|---------------------|-------------|
| **Создание нового заказа** | Primary | 0 секунд | - Операция записи, всегда на primary<br>- Требует немедленной консистентности |
| **Просмотр истории заказов пользователя** | Secondary | 2-5 секунд | - Пользователь просматривает старые заказы<br>- Небольшая задержка приемлема<br>- Разгружает primary |
| **Отображение статуса текущего заказа** | Primary | 0 секунд | - **Критично**: пользователь ожидает актуальный статус<br>- Статус может меняться часто (processing → shipped)<br>- Важно для UX и доверия клиента |
| **Поиск заказа по order_id (для клиента)** | Primary | 0 секунд | - Обычно запрашивается сразу после создания<br>- Пользователь ожидает увидеть свой заказ немедленно |
| **Поиск заказа по order_id (для администратора)** | Secondary | 2-5 секунд | - Административные операции менее критичны<br>- Можно использовать secondary для разгрузки |
| **Аналитика по заказам (отчеты)** | Secondary | 30-60 секунд | - Аналитические запросы не требуют real-time данных<br>- Можно использовать данные с задержкой<br>- Тяжелые запросы не должны нагружать primary |
| **Фильтрация заказов по статусу** | Secondary | 5-10 секунд | - Административная операция<br>- Небольшая задержка приемлема |

### 1.3. Коллекция `carts`

| Операция | Primary/Secondary | Допустимая задержка | Обоснование |
|----------|-------------------|---------------------|-------------|
| **Получение активной корзины пользователя** | Primary | 0 секунд | - **Критично**: корзина часто обновляется<br>- Пользователь ожидает видеть актуальное содержимое<br>- Риск показа устаревших данных |
| **Добавление товара в корзину** | Primary | 0 секунд | - Операция записи, всегда на primary<br>- Требует немедленной консистентности |
| **Удаление товара из корзины** | Primary | 0 секунд | - Операция записи, всегда на primary<br>- Требует немедленной консистентности |
| **Обновление количества товара** | Primary | 0 секунд | - Операция записи, всегда на primary<br>- Требует немедленной консистентности |
| **Поиск заброшенных корзин (для маркетинга)** | Secondary | 60-300 секунд | - Маркетинговые операции не требуют real-time данных<br>- Можно использовать данные с большой задержкой<br>- Тяжелые запросы не должны нагружать primary |

## 2. Общие рекомендации по допустимой задержке репликации

### 2.1. Критерии выбора допустимой задержки

| Тип операции | Допустимая задержка | Обоснование |
|--------------|---------------------|-------------|
| **Критичные для бизнеса** | 0 секунд (Primary) | - Проверка остатков перед покупкой<br>- Отображение статуса заказа<br>- Работа с корзиной |
| **Пользовательские (UX-критичные)** | 2-5 секунд | - Просмотр истории заказов<br>- Поиск заказа администратором |
| **Каталог и справочники** | 5-10 секунд | - Просмотр товаров<br>- Фильтрация по категориям |
| **Аналитика и отчеты** | 30-60 секунд | - Статистика по заказам<br>- Отчеты по остаткам |
| **Маркетинг и фоновые задачи** | 60-300 секунд | - Поиск заброшенных корзин<br>- Email-рассылки |

### 2.2. Настройка Read Concern

Для обеспечения требуемого уровня консистентности рекомендуется использовать следующие уровни Read Concern:

- **Для критичных операций** (проверка остатков, статус заказа): `readConcern("majority")` - гарантия, что данные реплицированы на большинство узлов
- **Для обычных операций чтения**: `readConcern("local")` - быстрое чтение без ожидания репликации

### 2.3. Мониторинг задержки репликации

Необходимо настроить мониторинг replication lag и установить алерты:

**Критические пороги для алертов:**
- Warning: replication lag > 5 секунд
- Critical: replication lag > 30 секунд

## 3. Риски и их минимизация

### 3.1. Риск продажи недоступного товара

**Проблема:** Если проверка остатков выполняется на secondary с задержкой, товар может быть продан другому покупателю на primary, но secondary еще не получил обновление.

**Решение:**
1. Всегда проверять остатки на primary перед добавлением в корзину
2. Финальная проверка при оформлении заказа также на primary
3. Использовать транзакции для атомарности операций

### 3.2. Риск отображения устаревшего статуса заказа

**Проблема:** Пользователь видит статус "processing", хотя заказ уже "shipped".

**Решение:**
1. Всегда читать статус заказа с primary
2. Использовать WebSocket/SSE для real-time обновлений статуса
3. Кешировать на клиенте с коротким TTL (30-60 секунд)

### 3.3. Риск рассинхронизации корзины

**Проблема:** Пользователь добавил товар, но видит старую версию корзины.

**Решение:**
1. Все операции с активными корзинами только на primary
2. Использовать optimistic UI updates на клиенте
3. Периодическая синхронизация корзины (каждые 30 секунд)
