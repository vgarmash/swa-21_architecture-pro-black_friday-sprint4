### <a name="_b7urdng99y53"></a>**Название задачи: Task 8. Перегрузка шарда**  

### <a name="_3bfxc9a45514"></a>**Описание проблемы**  
Из-за категории «Электроника» произошла перегрузка одного из шардов MongoDB, так как 70% запросов приходилось именно на эти товары. Поэтому сейчас нужно разработать стратегию, как выявлять и устранять такие «горячие» шарды, а ещё предложить метрики мониторинга, чтобы в будущем можно было предотвращать такие ситуации. Не забудьте учесть, что товары из популярных категорий могут создавать непропорциональную нагрузку на отдельные узлы.
Что нужно сделать:
- Разработайте набор метрик, чтобы отслеживать состояние шардов.
- Предложите механизмы автоматического перераспределения данных.

Основные запросы по товарам:
1. Обновление остатков. Пример: покупка 2 смартфонов Х в Москве
2. Поиск товаров по категориям и фильтрация по диапазону цен. Пример: поиск всех смартфонов от 20 до 60 т.р в наличии в Москве 
3. Получить описание товара на странице продукта - рекомендуется разделить на 2 запроса:
-----
### <a name="_qmphm5d6rvi3"></a>**Решение**  
#### Мониторинг
Для мониторинга состояния шардов рекомендуется использоваться следующие метрики:
- Hardware нагрузка:
  - CPU
  - RAM
  - I/O
- Нагрузка на чтение, запись:
  - количество операций read
  - количество операций write
- Active connections - число соединений на каждом шарде
- Время ответа на запрос
- Частота миграций между чанками
- Объем данных в шарде

На появление "горячего" узла могут указывать следующие признаки:
1. резкий рост количества чтений/записи (либо числа соединений, либо объема данных шарда) по сравнению с другими узлами
  - если при этом время ответа не увеличивается (среднее время ответа ~200 мс), CPU остается ниже 80%, скорее всего нагрузка обрабатываетс янормально
2. долгое время ответа (более 200-500 мс), высокая частота миграций
  - миграции создают фоновую нагрузку, которая влияет на производительность и время ответа, при этом остальные параметры могут не сильно отличаться от средних. В таком случае стоит пересмотреть ключ шардирования на "менее изменяемый"

#### Автоматическое перераспределение данных
0. Для автоматического перераспределения данных по шардам необходим балансировщик:

    Подключаем балансировщик
    ```
    sh.setBalancerState(true);
    ```
    Проверяем состояние балансировщика:
    ```
    sh.getBalancerState();
    ```
    Можно ограничить время работы балансировщика (время, в которое будут перераспределяться данные, например ночью, чтобы не влиять на работу пользователей):
    ```
    sh.setBalancerWindow({
      start: "02:00",
      stop: "06:00"
    });
    ```
1. Использование составного ключа шардирования, например category_id + product_id

    Такой ключ будет все еще эффективен при поиске по первому ключу шардирования (фильтрация по категории), при этом более равномерно распределит данные
    Пример команды:
    ```
    sh.shardCollection("db.products", { category.main_category_id: 1, _id_: 1 });
    ```
2. Консистентное хэширование

    Консистентное хэширование позволит добавлять новые ноды без перетасовки всех данных на остальных шардах. Логика такая:
    - При появлении новой ноды, она регистрируется
    - От адреса ноды берется хэш функция, сервер располагается на "хэш-кольце", получает свой "ключ" (например 30)
    - При появлении нового объекта для сохранения или поиска, вычисляется хэш функция от ключа объекта (например 28)
    - Хэш объекта маппится на хэш сервера по "часовой стрелке" (следующий по возрастанию в большинстве случаев)
    При появленийи новой ноды, она забирает часть диапазонов и пересортировать нужно только данные соседних нод, не затрагивая остальные.
    - Этом механизм работает "из коробки" для Cassandra DB, более оптимально перейти на такую БД, чем реализовавать самостоятельно

3. Сервис поиска шарда с кастомной логикой перераспределения данных

    Сервис может регистрировать повышенную нагрузку на шард с определенной категорией, поднимать дополнительные ноды и распределять эту категорию по нескольким шардам по доп. ключу (например по диапазону цен, т.к. это частый фильтр в запросах пользователя)
    Пример команды на деление чанка начиная с указанного значения ключа:
    ```
    sh.splitAt("db.products", { category: "electronics", "_id": 1000 });
    ```
