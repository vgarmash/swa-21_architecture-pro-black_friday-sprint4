# Task 7 Шардирование коллекций MongoDB

### Orders

```
{
  _id: ObjectId,
  user_id: ObjectId,
  created_at: ISODate,
  items: [
    {
      product_id: ObjectId,
      price: Decimal128,
      quantity: NumberInt
    }
  ],
  status: NumberInt, // OrderStatuses
  total: Decimal128,
  geo_zone: ObjectId // GeoZones
}
```

**Ключ**: geo_zone

**Метод**: geo sharding

**Комментарий**: Географическая зона совместно с геошардингом позволит распределить заказы по шардам, которые находятся ближе к пользователю, что ускорит работу пользователя с заказом.

### Products

```
{
  _id: ObjectId,
  name: String,
  category: ObjectId,
  price: Decimal128,
  inventory: [
    { 
      geo_zone: ObjectId, 
      balance: Decimal128 
    }
  ],
  attributes: {
    color?: String,
    size?: String,
    ...
  }
}
```

**Ключ**: price

**Метод**: range based sharding

**Комментарий**: цена товара вместе с диапазонным шардированием позволит более гибко масштабировать ресурсы под разные сценарии нагрузок (напр. более дешевые товары покупаются чаще, чем более дорогие).

### Carts

```
{
  _id: ObjectId,
  user_id?: ObjectId,
  session_id?: String,
  items: [
    {
      product_id: ObjectId,
      quantity: NumberInt
    }
  ],
  status: String, // "active", "ordered", "abandoned"
  created_at: ISODate,
  updated_at: ISODate,
  expires_at: ISODate
}
```

**Ключ**: user_id + session_id

**Метод**: key based sharding

**Комментарий**: идентификатор пользователя (либо идентфиикатор сеанса в случае неавторизованного пользователя) совместно с хэшированным шардированием позволят равномерно распределить корзины пользователей между шардами, что даст более равномерную нагрузку и усреднит время поиска корзины, а также удаления корзины по ttl.

### Дополнительные (опциональные) коллекции:

### OrderStatuses

```
{
  _id: NumberInt, // 0, 1, 2
  name: String, // "created", "paid", "shipped"
  description: String, // "Создан", "Оплачен", "Отправлен"
}
```

### GeoZones

```
{
  _id: ObjectId,
  name: String, // "msk", "spb", "ekb"
  full_name: String, // "Москва", "Санкт-Петербург"
  timezone: String // "Europe/Moscow"
}
```

### ProductCategories

```
{
  _id: ObjectId,
  name: String, // "smartphones"
  name_ru: String, // "Смартфоны"
}
```

---


# Task 8 Выявление и устранение «горячих» шардов

### Набор метрик

1. **Количество операций**: Количество запросов (find, update, insert) на шард (в секунду).
2. **Задержка запросов (latency)**: 99-й перцентиль времени ответа.
3. **CPU и RAM**: Процент загруженности процессора и оперативной памяти.
4. **Размер чанков**: Средний размер чанков на шарде (в MB).
5. **Количество чанков**: Число чанков на шардах, дисбаланс между шардами.
6. **Частота миграций чанков**: Количество перемещений чанков между шардами (за час).

Источники данных:
1. Логи балансировщика (mongos)
2. MongoDB Atlas
3. Prometheus + Grafana

Примеры логов балансировщика:
1. Перемещение чанков
```
use config
dbd.changelog.find({ what: { $in: ["moveChunk.start", "moveChunk.commit"] } })
```

2. Статистика по чанкам
```
use config
db.chunks.aggregate([
  { $match: { ns: "products" } },
  { $group: { _id: "$shard", count: { $sum: 1 } } }
])
```

### Механизмы перераспределения данных

1. **Изменение ключа по категории на составной**
Например по категории + цене:

```
db.shardCollection("products", { category: 1, price: "hashed" })
```

2. **Добавление шарда под горячие данные**
Например, выделение отдельного шарда под категорию "электроника"

3. **Алерты на дисбаланс чанков**
Периодический сбор метрик по чанкам в приложении, отправка оповещений в случае превышения порогов.

---

# Task 9 Настройка чтения с реплик и консистентность

### **Операции чтения:**

### **1. Коллекция `orders`**
| **Операция**                          | **Откуда читать** | **Допустимая задержка** | **Обоснование** |
|---------------------------------------|-------------------|-------------------------|----------------|
| История заказов пользователя | Secondary | ≤ 10 сек | Не критично, если заказ не сразу появляется в истории
| Отображение текущего статуса заказа | Primary | 0 сек | Критично, пользователь должен видеть актуальный статус
| Отчеты по заказам | Secondary | ≤ 3 мин | Не критично, допустима устаревшая информация для отчетности

---

### **2. Коллекция `products`**
| **Операция**                          | **Откуда читать** | **Допустимая задержка** | **Обоснование** |
|---------------------------------------|-------------------|-------------------------|----------------|
| Поиск товаров по фильтрам | Secondary | ≤ 5 сек | Не критично, если пользователь видит устаревший остаток (риск: товар может быть уже продан, но это обрабатывается на уровне приложения при оформлении заказа)
| Отображение карточки товара | Secondary | ≤ 3 сек | Не критично, но пользователь должен видеть актуальные данные, допустима только  небольшая задержка
| Проверка остатков перед подтверждением заказа | Primary | 0 сек | Критично для избежания продажи закончившихся товаров

---

### **3. Коллекция `carts`**
| **Операция**                          | **Откуда читать** | **Допустимая задержка** | **Обоснование** |
|---------------------------------------|-------------------|-------------------------|----------------|
| Отображение активной корзины | Primary | 0 сек | Критично, пользователь должен видеть актуальное содержимое корзины для работы
| Анализ брошенных корзин (аналитика) | Secondary | ≤ 3 мин | Не критично, допустима устаревшая информация для отчетности

---

### **Настройки чтения в коде с примерами на c#**

1. **Secondary для истории заказов:** Задержка допустима, так как данные не критичны в реальном времени.
```csharp
var orders = database.GetCollection<Order>("orders")
    .Find(o => o.UserId == userId)
    .WithReadPreference(ReadPreference.SecondaryPreferred)
    .ToList();
```

2. **Primary для статусов заказов:** Пользователь должен видеть актуальное состояние заказа.
```csharp
var order = database.GetCollection<Order>("orders")
    .Find(o => o.Id == orderId)
    .WithReadPreference(ReadPreference.Primary)
    .FirstOrDefault();
```

3. **Вторичные реплики товаров:** Подходят для поиска по каталогу, так как небольшая задержка не влияет на UX.
```csharp
var products = database.GetCollection<Product>("products")
    .Find(p => p.Category == "electronics")
    .WithReadPreference(ReadPreference.SecondaryPreferred)
    .ToList();
```

4. **Primary для товаров:** Обязателен для проверки остатков, чтобы избежать overselling.
```csharp
var product = database.GetCollection<Product>("products")
    .Find(p => p.Id == productId)
    .WithReadPreference(ReadPreference.Primary)
    .FirstOrDefault();
```

5. **Primary для корзины:** Корзина часто обновляется, и чтение с реплик может привести к конфликтам.
```csharp
var cart = database.GetCollection<Cart>("carts")
    .Find(c => c.UserId == userId && c.Status == "active")
    .WithReadPreference(ReadPreference.Primary)
    .FirstOrDefault();
```

6. **Вторичные реплики корзин:** Допустима задержка для аналитики (анализа брошенных корзин).
```csharp
var abandonedCarts = database.GetCollection<Cart>("carts")
    .Find(c => c.Status == "abandoned")
    .WithReadPreference(ReadPreference.SecondaryPreferred)
    .ToList();
```

---

# Task 10 Миграция на Cassandra

## Task 10.1 Обоснование использования для сущностей

| Данные | Критичность | Подходит для Cassandra? | Обоснование
|-|-|-|-
| Заказы | Высокая | Нет | Требуется строгая целостность, Cassandra не поддерживает ACID-транзакции между разными партициями.  
| Товары | Средняя | Да | Высокая скорость чтения, горизонтальное масштабирование при росте каталога, данные часто читаются (Cassandra оптимизирована для чтений по первичному ключу), не требуются сложные соединения, партиционирование по разным ключам позволяет распределить нагрузку и быстро находить все товары в категории.
| Корзины | Высокая | Да | Частые записи (добавление товаров в корзину), низкая задержка, высокая доступность, возможно отсутствие строгой транзакционной целостности в пользу скорости и отказоустойчивости.
| История заказов | Низкая | Нет | Данные пишутся один раз и редко обновляются, требуют аналитических запросов / агрегаций. 
| Сессии пользователей | Высокая | Да | Высокая скорость записи / чтения, отказоустойчивость, частые записи, отказоустойчивость. 

---

## Task 10.2 Ключи партиционирования для сущностей

### 10.2.1. Товары

```sql
CREATE TABLE products (
    category TEXT,              -- Категория товара
    product_id UUID,            -- ID товара
    name TEXT,
    price DECIMAL,
    inventory MAP<TEXT, INT>,   -- Остатки по геозонам {"msk": 50, "spb": 30}
    attributes MAP<TEXT, TEXT>, -- Доп. атрибуты {"color": "red", "storage": "256GB"}
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    PRIMARY KEY ((category, product_id))
);
```

**Паттерн доступа:** Частые чтения по категориям и фильтрам (сложная сортировка на уровне приложения), получение товаров по id, редкие обновления остатков.

- **Partition key:** `(category, product_id)`  
  - Равномерное распределение: ключ `(category, product_id)` избегает концентрации данных (нет очень больших категорий на одном узле).  
  - Эффективные запросы: `WHERE category = 'x' AND product_id = 123`.  

- **Кластерный ключ:**
  - Не требуется специальный. Внутри партиции (все товары одной категории) данные хранятся в порядке их записи. 


---

### 10.2.2. Корзины

```sql
CREATE TABLE carts (
    user_id UUID,             -- ID пользователя
    session_id TEXT,          -- ID сессии для неавторизованных пользователей
    cart_id UUID,             -- ID корзины
    items LIST<FROZEN<item>>, -- Товары: {product_id, quantity}
    status TEXT,              -- active/ordered/abandoned
    expires_at TIMESTAMP,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    PRIMARY KEY ((user_id, session_id), cart_id)
) WITH CLUSTERING ORDER BY (updated_at DESC)
  AND default_time_to_live = 86400;
```

- **Паттерн доступа:** Частые записи (обновления), чтение по пользователю или сессии.

- **Partition key:** `(user_id, session_id)`  
  - Равномерное распределение: ключ `(user_id, session_id)` распределяет нагрузку равномерно (нет пользователей с гигантскими корзинами).
  - Избегает горячих партиций: каждый пользователь/сессия — отдельная партиция.  
  - Горячие партиции не возникают, так как `user_id` уникален.  

- **Кластерный ключ:** `updated_at`
  - `updated_at` в качестве кластерного ключа обеспечивает порядок по времени обновления.

---

### 10.2.3. Cессии пользователей

```sql
CREATE TABLE sessions (
    session_id TEXT,         -- ID сессии
    user_id UUID,            -- ID пользователя
    data MAP<TEXT, TEXT>,    -- Данные сессии
    last_activity TIMESTAMP,
    expires_at TIMESTAMP,
    PRIMARY KEY (session_id)
) WITH CLUSTERING ORDER BY (last_activity DESC)
  AND default_time_to_live = 3600;
```

- **Паттерн доступа:** Частые записи/чтения, низкая задержка.

- **Partition key:** `session_id`  
  - Равномерное распределение: хэш от `session_id` гарантирует баланс.  
  - Быстрый доступ: получение сессии по ID за O(1).  

- **Кластерный ключ:** `last_activity`
  - Все события в рамках одной сессии (одной партиции) будут упорядочены по времени последней активности по убыванию, что ускоряет самые частые запросы на получение состояния сессии.

---

## Task 10.3 Стратегии восстановления данных для сущностей

### 10.3.1. Товары

- **Read Repair:** При каждом чтении исправлять расхождения, это критично для остатков товаров, чтобы избежать overselling.
- **Anti-Entropy Repair:** Регулярная проверка для гарантии целостности цен и атрибутов.

**Обоснование:** Данные товаров должны быть согласованы между реплика, так как несогласованность остатков может привести к финансовым потерям, это обеспечивается Read Repair и Anti-Entropy Repair.

**Компромиссы между latency и согласованностью:**
  - `WRITE = QUORUM`, `READ = LOCAL_QUORUM` - баланс скорости и согласованности.

---

### 10.3.2. Корзины

- **Read Repair:** Постепенно исправляет расхождения при чтениях без серьезных потерь производительности.
- **Hinted Handoff**: Обеспечивает запись при кратковременном падении ноды, пользователь может добавить товар в корзину даже при сетевых сбоях.

**Обоснование:** Для корзин доступность важнее строгой согласованности, кратковременная несогласованность допустима (напр. перед появлением товара в корзине).

**Компромиссы между latency и согласованностью:**
  - `WRITE = ONE`, `READ = ONE` - скорость важнее, для критичных операций `QUORUM` (напр. оформление заказа).

---

### 10.3.3. Сессии пользователей

- **Hinted Handoff:** Сессии имеют TTL, поэтому расхождения автоматически разрешатся со временем.

**Обоснование:** Сессии — временные данные, строгая согласованность не нужна, так как сессия может быть пересоздана.

**Компромиссы между latency и согласованностью:**
  - `WRITE = ONE`, `READ = ONE` - максимальная скорость.
