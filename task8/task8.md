# Задание 8. Выявление и устранение «горячих» шардов

## Проблема

В коллекции [`products`] с шард-ключом `{ category: 1, _id: 1 }` возникла перегрузка одного из шардов из-за категории "Электроника", на которую приходится 70% запросов. Это классический пример "горячего" шарда, когда неравномерное распределение нагрузки приводит к деградации производительности.

## 1. Метрики мониторинга шардов

### 1.1. Базовые метрики распределения данных

#### Размер данных по шардам

```javascript
// Получение статистики по всем шардам
db.adminCommand({ listShards: 1 })

// Детальная статистика по коллекции products
db.products.getShardDistribution()

// Пример вывода:
// Shard shard01 at shard01/mongo-shard01:27017
//   data : 15GiB docs : 500000 chunks : 120
//   estimated data per chunk : 128MiB
//   estimated docs per chunk : 4166
//
// Shard shard02 at shard02/mongo-shard02:27017
//   data : 5GiB docs : 150000 chunks : 40
//   estimated data per chunk : 128MiB
//   estimated docs per chunk : 3750
```

**Критические пороги:**
- Разница в размере данных между шардами > 30% → требуется балансировка
- Разница в количестве документов > 40% → неравномерное распределение

#### Распределение чанков

```javascript
// Анализ распределения чанков по шардам
use config
db.chunks.aggregate([
  { $match: { ns: "shop.products" } },
  { $group: {
      _id: "$shard",
      count: { $sum: 1 },
      minKey: { $min: "$min" },
      maxKey: { $max: "$max" }
  }},
  { $sort: { count: -1 } }
])

// Пример результата:
// { "_id": "shard01", "count": 120, "minKey": {...}, "maxKey": {...} }
// { "_id": "shard02", "count": 40, "minKey": {...}, "maxKey": {...} }
// { "_id": "shard03", "count": 35, "minKey": {...}, "maxKey": {...} }
```

**Критические пороги:**
- Разница в количестве чанков > 8 → балансировщик должен запуститься
- Один шард содержит > 50% всех чанков → критическая неравномерность

### 1.2. Метрики производительности

#### Критические пороги для мониторинга

Для эффективного выявления "горячих" шардов необходимо определить критические пороги для каждой метрики:

**Распределение данных:**
- Разница в размере данных между шардами > **30%** → требуется балансировка
- Разница в количестве документов > **40%** → неравномерное распределение
- Разница в количестве чанков > **8** → балансировщик должен запуститься

**Производительность операций:**
- Количество операций на одном шарде > **150%** от среднего → "горячий" шард
- Latency чтения > **100ms** → проблемы с производительностью чтения
- Latency записи > **100ms** → проблемы с производительностью записи

**Ресурсы:**
- CPU usage > **80%** → перегрузка шарда
- Memory usage > **85%** → риск OOM (Out of Memory)
- Page faults > **100/sec** → недостаточно RAM
- Количество активных соединений > **80%** от максимума → перегрузка

**Категории товаров:**
- Одна категория получает > **40%** всех запросов → "горячая" категория
- Средняя длительность запросов > **100ms** → медленные запросы

#### Подход к сбору метрик

**1. Операции чтения/записи по шардам**

Для каждого шарда необходимо собирать:
- Количество операций (query, insert, update, delete) через `db.serverStatus().opcounters`
- Активные операции через `db.currentOp()` для выявления долгих запросов
- Статистику соединений через `db.adminCommand({ shardConnPoolStats: 1 })`

**Анализ:** Вычислить среднее количество операций по всем шардам. Если на одном шарде операций в 1.5 раза больше среднего — это "горячий" шард.

**2. Latency операций**

Собирать через `db.serverStatus().opLatencies`:
- Latency чтения (reads)
- Latency записи (writes)
- Latency команд (commands)

**Анализ:** Если latency превышает 100ms — требуется оптимизация индексов или добавление read replicas.

**3. Использование соединений**

Мониторить через `db.serverStatus().connections`:
- Текущее количество соединений (current)
- Доступные соединения (available)
- Процент использования = current / (current + available) × 100%

**Анализ:** Если использовано > 80% соединений — увеличить `maxIncomingConnections` или оптимизировать connection pooling.

**4. Распределение данных и чанков**

Для каждого шарда собирать:
- Размер данных через `db.collection.stats()`
- Количество документов
- Количество чанков через `db.getSiblingDB("config").chunks.countDocuments()`

**Анализ:** Сравнить значения между шардами. Разница > 30% в размере данных или > 8 чанков указывает на дисбаланс.

**5. Системные ресурсы**

Мониторить через `db.serverStatus()`:
- Использование памяти (mem.resident, mem.virtual)
- Page faults (extra_info.page_faults)
- CPU можно получить через внешние инструменты (Prometheus, node_exporter)

**Анализ:** Высокие page faults (> 100/sec) указывают на нехватку RAM. CPU > 80% — на перегрузку шарда.

**6. Анализ запросов по категориям**

Включить профилирование: `db.setProfilingLevel(1, { slowms: 100 })`

Анализировать `db.system.profile` для выявления:
- Какие категории запрашиваются чаще всего
- Средняя длительность запросов по категориям
- Процент запросов на каждую категорию

**Анализ:** Если одна категория получает > 40% запросов — это "горячая" категория, требующая разделения или изменения шард-ключа.

#### CPU и Memory по шардам

```javascript
// Мониторинг ресурсов через serverStatus
db.serverStatus().mem
db.serverStatus().extra_info

// Пример результата:
// {
//   "resident": 2048,      // MB в RAM
//   "virtual": 4096,       // MB виртуальной памяти
//   "mapped": 1024,        // MB mapped файлов
//   "mappedWithJournal": 2048
// }
```

**Критические пороги:**
- CPU usage > 80% → перегрузка шарда
- Memory usage > 85% → риск OOM
- Page faults > 100/sec → недостаточно RAM

### 1.3. Метрики балансировки

- Статус балансировщика — включен ли и работает ли в данный момент
- История миграций — количество, направление и длительность перемещений чанков

```javascript
// Статус балансировщика
sh.getBalancerState()
sh.isBalancerRunning()

// История балансировки
use config
db.changelog.find({
  what: "moveChunk.commit",
  time: { $gte: new Date(Date.now() - 24*60*60*1000) }
}).sort({ time: -1 }).limit(10)

// Статистика миграций
db.changelog.aggregate([
  { $match: { what: "moveChunk.commit" } },
  { $group: {
      _id: {
        from: "$details.from",
        to: "$details.to"
      },
      count: { $sum: 1 },
      avgDuration: { $avg: "$details.duration" }
  }},
  { $sort: { count: -1 } }
])
```

### 1.4. Метрики по категориям товаров

**Анализ распределения товаров по категориям:**

```javascript
db.products.aggregate([
  {
    $group: {
      _id: "$category",
      count: { $sum: 1 },
      avgPrice: { $avg: "$price" },
      totalStock: {
        $sum: {
          $sum: { $objectToArray: "$stock_by_zone" }.v
        }
      }
    }
  },
  { $sort: { count: -1 } }
])

// Результат покажет распределение товаров по категориям:
// { "_id": "Электроника", "count": 350000, "avgPrice": 25000, "totalStock": 1500000 }
// { "_id": "Книги", "count": 80000, "avgPrice": 800, "totalStock": 400000 }
// { "_id": "Одежда", "count": 70000, "avgPrice": 3000, "totalStock": 350000 }
```

**Мониторинг "горячих" категорий:**

Для выявления категорий, создающих непропорциональную нагрузку:

1. **Включить профилирование запросов:**
   ```javascript
   db.setProfilingLevel(1, { slowms: 100 })
   ```

2. **Анализировать `db.system.profile`** за определенный период (например, последний час):
   - Группировать запросы по категориям
   - Подсчитывать количество запросов на каждую категорию
   - Вычислять среднюю длительность запросов

3. **Применить критические пороги:**
   - Если категория получает > **40%** всех запросов → "горячая" категория
   - Если средняя длительность запросов > **100ms** → медленные запросы

4. **Действия при обнаружении:**
   - Сохранить алерт в коллекцию мониторинга
   - Рекомендовать разделение категории на подкатегории
   - Рассмотреть изменение шард-ключа на `{ category: 1, _id: "hashed" }`

## 2. Механизмы автоматического перераспределения данных

### 2.1. Настройка балансировщика

#### Базовая конфигурация

```javascript
// Включение балансировщика
sh.startBalancer()

// Настройка окна балансировки (только в нерабочее время)
use config
db.settings.updateOne(
  { _id: "balancer" },
  {
    $set: {
      activeWindow: {
        start: "01:00",  // 01:00 по UTC
        stop: "05:00"    // 05:00 по UTC
      },
      stopped: false
    }
  },
  { upsert: true }
)

// Проверка настроек
db.settings.findOne({ _id: "balancer" })
```

#### Настройка параметров миграции

```javascript
// Увеличение параллельных миграций (осторожно!)
db.adminCommand({
  setParameter: 1,
  maxParallelMigrations: 2  // По умолчанию 1
})

// Настройка размера чанка
use config
db.settings.updateOne(
  { _id: "chunksize" },
  { $set: { value: 64 } },  // 64 MB (по умолчанию 128 MB)
  { upsert: true }
)

// Меньший размер чанка = более гранулярная балансировка
// Но больше метаданных и overhead
```

### 2.2. Стратегия решения проблемы "горячей" категории

#### Вариант 1: Рефакторинг шард-ключа (рекомендуется)

**Проблема текущего шард-ключа `{ category: 1, _id: 1 }`:**
- Все товары категории "Электроника" попадают в один диапазон чанков
- Невозможно равномерно распределить популярную категорию

**Решение: Использование хешированного компонента**

```javascript
// Новый шард-ключ: { category: 1, _id: "hashed" }
// Это обеспечит равномерное распределение внутри категории

// Создание новой коллекции с правильным шард-ключом
db.adminCommand({
  shardCollection: "shop.products_v2",
  key: { category: 1, _id: "hashed" }
})

// Создание индексов
db.products_v2.createIndex({ category: 1, _id: "hashed" })
db.products_v2.createIndex({ category: 1, price: 1 })
db.products_v2.createIndex({ product_id: 1 }, { unique: true })

// Миграция данных (постепенно, чтобы не перегрузить систему)
const batchSize = 1000;
let skip = 0;

while (true) {
  const batch = db.products.find()
    .skip(skip)
    .limit(batchSize)
    .toArray();

  if (batch.length === 0) break;

  db.products_v2.insertMany(batch, { ordered: false });
  skip += batchSize;

  // Пауза между батчами
  sleep(100);
}

// После завершения миграции:
// 1. Переключить приложение на products_v2
// 2. Удалить старую коллекцию
// 3. Переименовать products_v2 в products
```

**Преимущества нового шард-ключа:**
-  Равномерное распределение товаров внутри категории
-  Сохранение эффективности запросов по категории
-  Предотвращение "горячих" шардов в будущем

**Недостатки:**
-  Невозможность эффективных range-запросов по `_id` внутри категории
-  Требуется миграция данных

#### Вариант 2: Разделение популярных категорий

```javascript
// Разбиение категории "Электроника" на подкатегории
db.products.updateMany(
  { category: "Электроника" },
  [
    {
      $set: {
        category: {
          $switch: {
            branches: [
              {
                case: { $regexMatch: { input: "$name", regex: /смартфон|телефон/i } },
                then: "Электроника.Смартфоны"
              },
              {
                case: { $regexMatch: { input: "$name", regex: /ноутбук|компьютер/i } },
                then: "Электроника.Компьютеры"
              },
              {
                case: { $regexMatch: { input: "$name", regex: /телевизор|тв/i } },
                then: "Электроника.ТВ"
              },
              {
                case: { $regexMatch: { input: "$name", regex: /наушники|колонки/i } },
                then: "Электроника.Аудио"
              }
            ],
            default: "Электроника.Прочее"
          }
        }
      }
    }
  ]
)

// Теперь вместо одной "горячей" категории будет 5 более мелких
// Они распределятся по разным чанкам и шардам
```

**Преимущества:**
-  Не требует изменения шард-ключа
-  Быстрое решение
-  Улучшает UX (более точная категоризация)

**Недостатки:**
-  Требует изменения логики приложения
-  Не решает проблему полностью, если одна подкатегория всё равно популярна

#### Вариант 3: Зонирование (Zone Sharding)

```javascript
// Создание зон для распределения популярных категорий
// Зона 1: Электроника на выделенных шардах
sh.addShardToZone("shard01", "electronics_zone")
sh.addShardToZone("shard02", "electronics_zone")

// Зона 2: Остальные категории
sh.addShardToZone("shard03", "general_zone")
sh.addShardToZone("shard04", "general_zone")

// Привязка диапазонов к зонам
sh.updateZoneKeyRange(
  "shop.products",
  { category: "Электроника", _id: MinKey },
  { category: "Электроника", _id: MaxKey },
  "electronics_zone"
)

sh.updateZoneKeyRange(
  "shop.products",
  { category: "Аудио", _id: MinKey },
  { category: "Электроника", _id: MinKey },
  "general_zone"
)

sh.updateZoneKeyRange(
  "shop.products",
  { category: "Электроника", _id: MaxKey },
  { category: MaxKey, _id: MaxKey },
  "general_zone"
)
```

**Преимущества:**
-  Выделение мощных серверов под популярные категории
-  Гибкое управление распределением
-  Не требует изменения шард-ключа

**Недостатки:**
-  Требует дополнительное оборудование
-  Сложность настройки и поддержки
