### <a name="_b7urdng99y53"></a>**Название задачи: Task 8. Перегрузка шарда**  

### <a name="_3bfxc9a45514"></a>**Описание проблемы**  
Во время «чёрной пятницы» интернет-магазин использовал MongoDB с шардированием на основе диапазонов (Range-Based Sharding). При резком увеличении нагрузки (50 000 запросов/сек.) возникла высокая задержка при масштабировании:
При добавлении новых шардов MongoDB полностью перераспределяла данные между всеми узлами, что вызывало просадку latency в пик нагрузки, так как система тратила ресурсы на перемещение данных.
Руководство решило перейти на БД Cassandra, чтобы обеспечить:
- Высокую отказоустойчивость (leaderless‑репликация).
- Быстрое горизонтальное масштабирование без полного перераспределения данных.
- Равномерное распределение данных.
------
#### Задание 10.1
Определите, какие части данных интернет-магазина (например, заказы, товары, корзины, история заказов, пользовательские сессии) являются критически важными с точки зрения целостности и скорости обработки.
Обоснуйте, для каких именно данных применение Cassandra имеет смысл (учтите требования к масштабируемости, геораспределённости, скорости записи/чтения и целостности данных). 
#### <a name="_qmphm5d6rvi3"></a>**Решение**  
Критические с т.з целостности и скорости обработки данные:
- Заказы + история заказов : обработка заказов требует правильной обработки транзакций и чувствительна к потере или дублированию данных -- Cassandra
- Корзина: требует быстрой обработки и максимально гибкой масштабируемости (во время распродаж пользователи очень активно пополняют корзины) -- Cassandra
- Остатки: требуют максимальной скорости обработки и обновления данных для корректных списания и отображения наличия.  -- Cassandra

Менее критичные данные:
- Товары: если остатки хранить отдельно от товаров, то сам каталог не требователен к гибкости. При повышенной активности на чтение каталога достаточно добавить реплики на чтение. В худшем случае в рамках master-slave архитектуры при отказе мастер ноды администратор не сможет добавить новые товары в течение времени выбора нового лидера в кластере, это можно считать допустимым, главное, что пользователи смогут просматривать каталог
- Пользовательские сессии: в зависимости от системы авторизации могут быть критичными данными. Например, если пользователь не может попасть на сайт без авторизации, пока не создана сессия, то отказ мастер узла может создать задержку и пользователь уйдет с сайта. Если сайт без автоирзации, а пользовательские сессии нужны только для аналитики (наиболее вероятно для Мегашоп)- не являются критичными данными
- Эти данные можно оставить в БД с master-slave репликацией, либо организовать обработку с менее строгим требованием согласованности


#### Задание 10.2
Разработайте концептуальную модель для выбранных критически важных сущностей.
Определите partition key и кластерные ключи для каждой сущности, объяснив, как они будут обеспечивать равномерное распределение данных и эффективный доступ в условиях экстремальной нагрузки.
Обоснуйте выбор модели с точки зрения возможных «горячих» партиций и минимизации влияния решардинга при изменении топологии кластера.

##### Решение
1. **Заказы**
    ```
    CREATE TABLE orders (
        order_id UUID,
        user_id UUID,
        created_at TIMESTAMP,
        total_price DECIMAL,
        status TEXT,
        geo_mark TEXT,
        PRIMARY KEY ((order_id))
    );
    ```
    Частые запросы:
    - получить данные заказа (по order_id)
    - получить статус заказа (по order_id)
    - создать заказ

    **Partition key**: order_id - обеспечит равномерное распределение заказов, т.к. основные операции проводятся по идентификатору. Хранение истории заказов предлагается вести отдельно как холодное хранилище с более оптимальным распределением данных по узлам
    
    **Влияние на появление "горячих узлов"**: низкое.Равномерное распределение объектов за счет случайности UUID7
    
    **Решардинг при изменении топологии кластера**: низкий при использовании консистентного хэширования

    ```
    CREATE TABLE order_details (
        order_id UUID,
        product_id UUID,
        quantity INT,
        price DECIMAL
        PRIMARY KEY ((order_id), product_id)
    );
    ```
    **Partition key**: order_id - состав одного заказа будет располагаться на одном узле

2. **История заказов**
    ```
    CREATE TABLE orders_history (
        order_id UUID,
        user_id UUID,
        created_at TIMESTAMP,
        total_price DECIMAL,
        status TEXT,
        geo_mark TEXT,
        PRIMARY KEY ((order_id))
    );
    ```

    Частые запросы:
    - получить историю заказов пользователя (по user_id)

    **Partition key**: user_id - заказы одного пользователя будут получены с одного узла. 

    **Clustering keys**: order_id, created_at - помогает сортировать результаты по порядку оформления

    **Влияние на появление "горячих узлов"**: среднее.Может вызвать неравномерную загрузку узлов в случае гиперактивного покупателя, но, считаем, что для этой предметной области разница в активности не существенна
    
    **Решардинг при изменении топологии кластера**: низкий при использовании консистентного хэширования

3. **Корзина**
    ```
    CREATE TABLE carts (
        cart_id UUID,
        user_id UUID,
        session_id UUID,
        created_at TIMESTAMP,
        updated_at TIMESTAMP,
        expires_at TIMESTAMP,
        status TEXT,
        products LIST<frozen<map<text, double>>>, // Массив товаров в формате <товар: количество>
    );
    ```
    Частые запросы:
    - просмотр корзины пользователя (по session_id/user_id + status = active)
    - изменение состава корзины

    **Partition key**: user_id - позволит оптимально выполнять запросы

    **Clustering keys**: status - позволит более оптимально находить активные корзины

    **Влияние на появление "горячих узлов"**: низкое. При допущении, что у пользователя есть одна корзина user_id является косвенным первичным ключом

    **Решардинг при изменении топологии кластера**: низкий при использовании консистентного хэширования

4. Остатки
    ```
    CREATE TABLE amounts (
        product_id UUID,
        geo_mark UUID,
        available INT
    );
    ```
    Частые запросы:
    - получить остатки по product_id в гео зоне geo_mark
    - обновить остатки по product_id в гео зоне geo_mark

     **Partition key**: product_id + geo_mark - позволит оптимально выполнять запросы

    **Clustering keys**: не требуется

    **Влияние на появление "горячих узлов"**: среднее. При появлении очень популярного товара запросы будут раскиданы по разным узлам в соответствии с гео зоной. При проведении акции в одном регионе по одному товару может появиться "горячий узел"

    **Решардинг при изменении топологии кластера**: низкий при использовании консистентного хэширования

#### Задание 10.3
Какие стратегии (Hinted Handoff, Read Repair, Anti-Entropy Repair) можно применить для обеспечения целостности данных?
Для каких сущностей вы выберете одну стратегию, а для каких — другую?
Обоснуйте свой выбор с учётом компромиссов между latency запросов и уровнем гарантии согласованности.

##### Решение
| Сущность                      | Стратегия                                | Комментарий                                                                                                                                                                                                                                |
|-------------------------------|------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Заказ                         | Read Repair + QUORUM                     | Важна быстрая консистентность ключей, чтобы не допустить дубликатов, но не обязателен полный кворум                                                                                                                                        |
| История заказов               | Hinted Handoff                           | История заказов не часто читаемые данные, но требуют актуальности по мере восстановления узла                                                                                                                                              |
| Корзина                       | Read Repair + QUORUM                     | Важна быстрая консистентность ключей, чтобы не допустить дубликатов, пользовательски ошибок при работе с корзиной. QUORUM ALL не обязателен, т.к. создаст доп задержки, а работа с корзиной достаточно активная                            |
| Остатки                       | Read Repair + QUORUM ALL                 | Самые читаемые данные, требуют высокой актуальности, поэтому выбран высокий уровень согласованности при чтении. Задержку при чтении можно компенсировать UI средствами (например пока пользователь изучает товар, сайт прогружает остатки) |
| Товары (отдельно от остатков) | Read Repair + не строгая согласованность | Ценность гарантированной согласованности ниже, чем важность низкой задержки, поэтому можно согласовывать данные при чтении, но не полным кворумом                                                                                          |
