# Архитектурный документ

## Cхемы коллецкий

### Orders

```json
{
  "_id": ObjectId,
  "customer_id": ObjectId,,
  "created_at": ISODate,
  "items": [
    {
      "product_id": ObjectId,
      "price": <decimal>,
      "quantity": <int>
    }
  ],
  "status": "<string>",
  "total": <decimal>,
  "geozone": "<string>"
}
```

Рекомендуемый шард-ключ: `customer_id (hashed)`.

```shell
sh.shardCollection("mobile_world.orders", { "customer_id": "hashed" });
```

Основная операция поиска — история заказов конкретного пользователя. Если реализовать шардирование по `customer_id`, то запросы `db.orders.find({customer_id: X})` будут попадать на один шард, что значительно улучшит производительность.

`customer_id` имеет высокую кардинальность, поэтому хэширование распределяет заказы равномерно по шардам.
Создание заказов равномерно распределено по `customer_id` — вставки равномерны.

### Products

```json
{
  "_id": ObjectId,
  "name": "<string>",
  "category": "<string>",
  "price": <decimal>,
  "stocks": [
    {
      "geozone": "<string>",
      "quantity": <int>
    }
  ],
  "attributes": {
    "color": "<string>",
    "size": "<string>",
  }
}
```

Рекомендуемый шард-ключ: `_id (hashed)`.

```shell
sh.shardCollection("mobile_world.products", { "_id": "hashed" });
```

Хэширование `_id` равномерно распределит документы по шардам и снизит риск концентрации горячих данных на одном шарде.

Поиск товара по `_id` будет целевым. Запросы по `category` и `price` не содержат шард-ключа — они будут обработаны нескольким шардами, но их можно ускорить локальными индексами по этим полям на каждом шарде.

### Carts

```json
{
  "_id": ObjectId,
  "user_id": ObjectId,
  "session_id": "<string>",
  "items": [
    {
      "product_id": ObjectId,
      "quantity": <int>
    }
  ],
  "status": "active" | "ordered" | "abandoned",
  "created_at": ISODate,
  "updated_at": ISODate,
  "expires_at": ISODate
}
```

Рекомендуемый шард-ключ: `session_id (hashed)`.

```sh
sh.shardCollection("mobile_world.carts", { "session_id": "hashed" });
```

Доступы к корзинам бывают по `session_id` (в случае гостевого) или `user_id` (залогиненный). Нельзя одновременно иметь шард-ключ, который будет всегда присутствовать в запросах (либо `session_id`, либо `user_id`), поэтому любая попытка выбрать один из них сделает запросы по другому полю менее оптимальнымм. Ввиду большего количества операций связанных с полем `session_id`, а также особенности процесса слияния корзин, можно сделать ввывод, что гостевых документов больше чем документов от залогиненных пользователей.


## Устранение и предотвращение горячих шардов

### Метрики мониторинга
- Docs per shard (`db.collection.getShardDistribution()`).
- Chunk imbalance (`sh.status()`, balancer logs).
- Replication lag.
- Query targeting (профайлер MongoDB).
- Category hit ratio.

### Механизмы устранения
- **Balancer** — автоматическая миграция чанков.
- **Zone sharding** — распределение категорий по нескольким шардам.
- **Split chunks** — ручное деление больших чанков:

    ```js
    sh.splitAt("mobile_world.products", { category: "Electronics", _id: MinKey })
    ```

## Чтение с реплик и консистентность

| Коллекция    | Операция                                                                                      |                             Replica Pref. |                Допустимая задержка | Описание                                                                                                     |
| ------------ | --------------------------------------------------------------------------------------------- | ----------------------------------------: | ---------------------------------: | ------------------------------------------------------------------------------------------------------------ |
| **products** | Просмотр каталога / список товаров (категории, фильтры)                                       |                      `secondaryPreferred` |                             5–30 s | Read-heavy, допускает небольшое устаревание; снижает нагрузку на primary.                                    |
| **products** | Загрузка описания товара (характеристики, фото)                                               |                      `secondaryPreferred` |                             5–30 s | Статичные данные/медиа — можно обслуживать со вторичных для масштабирования.                                 |
| **products** | Проверка остатка в ходе checkout / резервирование количества                                  |                  `primary` (primary-only) |                              0–1 s | Критичная операция: риск oversell; требует актуального значения и атомарности.                               |
| **products** | Окончательное подтверждение цены при оплате                                                   |                  `primary` (primary-only) |                              0–1 s | Цена может меняться — финальная валидация должна быть на primary.                                            |
| **orders**   | Просмотр исторических заказов (старые/архивные)                                               |                               `secondary` |                            10–30 s | Архивные/исторические данные допускают устаревание; подходят для чтения со вторичных.                        |
| **orders**   | История сразу после создания (read-after-write) — пользователь ожидает видеть новый заказ     | `primary` (или causal session + majority) |                              0–1 s | Read-after-write требование: пользователь должен сразу видеть свой заказ; primary гарантирует актуальность.  |
| **orders**   | Отображение статуса заказа (в процессе обработки) — критичные обновления                      |             `primary` (primary-preferred) |                        0–1 — 1–5 s | Актуальный статус важен для UX/логистики; допускается небольшой lag при causal/majority, но в целом primary. |
| **orders**   | Фоновые отчёты / аналитика по заказам                                                         |                               `secondary` | до 30 s (и больше, если допустимо) | Бэченд-аналитика и отчёты терпят устаревание — secondary разгружает primary.                                 |
| **carts**    | Получение/обновление активной корзины (user/session) — add/remove, просмотр в реальном потоке |                  `primary` (primary-only) |                              0–1 s | Очень изменяемый объект; нужен read-after-write и отсутствие race conditions.                                |
| **carts**    | Слияние гостевой корзины в пользовательскую (merge)                                           |                  `primary` (primary-only) |                              0–1 s | Merge — конкурирующая операция; чтение/запись только на primary для корректности.                            |
| **carts**    | Фоновые сканы abandoned carts / аналитика                                                     |                               `secondary` |                            до 30 s | Аналитика и фоновые очистки могут выполняться со вторичных узлов.                                            |

## Миграция на Cassandra: модель данных, стратегии репликации и шардирования

### Применимость Cassandra к сущностям с т.з. критичности

| Сущность                        | Критичность   | Требования                                                                     | Применимость Cassandra | Обоснование                                                                                                                                                                                                              |
| ------------------------------- | ------------- | ------------------------------------------------------------------------------ | ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **orders** (заказы)             | Очень высокая | Высокая скорость записи, геораспределённость, доступ к истории по пользователю | **Да**               | Высокий write-throughput (создание заказов), возможность горизонтального масштабирования по пользователям/геозонам. Cassandra обеспечивает append-only модель и eventual consistency, что подходит для хранения истории. |
| **products** (товары и остатки) | Средняя       | Частые обновления остатков, важна согласованность при checkout                 |  **Частично**        | Основные сведения о товарах (цены, атрибуты) можно хранить кэшированными. Остатки лучше хранить в системе с сильной консистентностью (например, Redis + транзакционный стор). В Cassandra — только кэш доступности.      |
| **carts** (корзины)             | Высокая       | Частое обновление, временные данные, TTL                                       | **Да**               | Cassandra хорошо подходит для временных объектов (TTL, быстрая запись, высокая скорость инсертов, распределённость).                                                                                                     |
| **user_sessions**               | Средняя       | Временные данные, высокая скорость вставки и TTL                               | **Да**               | Классический кейс для Cassandra (session store с TTL).                                                                                                                                                                   |
| **order_history / audit**       | Низкая        | Большой объём данных, требуется только последовательное чтение                 | **Да**               | Cassandra оптимизирована под write-heavy, append-only модели. Отлично подходит для аудита.                                                                                                                               |

### Концептуальная модель данных под Cassandra

#### orders_by_user

Таблица `orders_by_user` для быстрого доступ к истории заказов пользователя, создание заказа в реальном времени.

```sql
CREATE TABLE orders_by_user (
    user_id UUID,
    order_id UUID,
    order_date TIMESTAMP,
    status TEXT,
    total_amount DECIMAL,
    region TEXT,
    items LIST<FROZEN<item>>,
    PRIMARY KEY ((user_id), order_date, order_id)
) WITH CLUSTERING ORDER BY (order_date DESC);
```

##### Ключи и балансировка

- Partition key: `user_id` — равномерное распределение по пользователям.
- Clustering keys: `(order_date, order_id)` — сортировка заказов по времени.
- Hotspot mitigation: при высокой активности пользователей из одной геозоны можно использовать составной ключ:
` ((region, user_id), order_date, order_id)` — равномерное распределение по регионам.

##### Обоснование

Cassandra не делает range-splits как MongoDB. Данные автоматически равномерно распределяются по hash(user_id), поэтому при добавлении нового узла данные переносятся частично, не полностью.

#### carts_active
Таблица `carts_active` для хранения текущих активных корзин (временные данные, TTL).

```sql
CREATE TABLE carts_active (
    user_id UUID,
    session_id TEXT,
    updated_at TIMESTAMP,
    items MAP<UUID, INT>,
    status TEXT,
    PRIMARY KEY ((user_id), session_id)
) WITH default_time_to_live = 86400;
```

##### Ключи и балансировка

Partition key: `user_id` — равномерное распределение по пользователям.
Clustering key: `session_id` — несколько сессий на одного пользователя.
TTL: 24 часа (очистка устаревших корзин без нагрузки на систему).

##### Обоснование

Модель “write once, update in place” идеально подходит Cassandra. При увеличении нагрузки добавление узлов не вызывает глобального перераспределения.

#### products_cache_by_region

Таблица `products_cache_by_region` - кэш сведений о товарах по геозоне (для локальных витрин и стоков).

```sql
CREATE TABLE products_cache_by_region (
    region TEXT,
    category TEXT,
    product_id UUID,
    name TEXT,
    price DECIMAL,
    stock INT,
    PRIMARY KEY ((region, category), product_id)
);
```

##### Ключи и балансировка

Partition key: `(region, category)` — предотвращает концентрацию всех записей в одной партиции.
Clustering key: `product_id` — доступ к товарам внутри региона/категории.

##### Обоснование:

Позволяет равномерно распределить кэш продуктов по регионам. При изменении стоков обновляется локально.
Основной источник истины (например, PostgreSQL или MongoDB) может синхронизироваться через CDC.

#### user_sessions

Таблица `user_sessions` - временное хранилище активных сессий пользователей.

```sql
CREATE TABLE user_sessions (
    region TEXT,
    user_id UUID,
    session_id UUID,
    created_at TIMESTAMP,
    last_active TIMESTAMP,
    PRIMARY KEY ((region, user_id), session_id)
) WITH default_time_to_live = 3600;
```

##### Обоснование:
Сессии — временные данные, TTL обеспечивает автоудаление, без централизованной чистки.
Регион как часть ключа гарантирует равномерное распределение и локализацию трафика.

#### order_history_by_region

Таблица `order_history_by_region` - аналитика и отчеты по регионам (append-only модель).

```sql
CREATE TABLE order_history_by_region (
    region TEXT,
    order_date DATE,
    order_id UUID,
    user_id UUID,
    total_amount DECIMAL,
    PRIMARY KEY ((region, order_date), order_id)
);
```

##### Обоснование:
- Partition key: `(region, order_date)` обеспечивает сегментацию данных по гео и дням, предотвращая «горячие» партиции.
- Cassandra эффективно масштабирует write-heavy поток заказов.

### Стратегии обеспечения целостности данных

| Стратегия                             | Применение                                                   | Для каких сущностей                                       | Обоснование                                                                                                                               |
| ------------------------------------- | ------------------------------------------------------------ | --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| **Hinted Handoff**                    | Короткие сетевые сбои, автоматическое восстановление записей | `orders`, `carts_active`, `user_sessions`                 | Повышает доступность: если один узел недоступен, записи временно хранятся на других и доставляются позже. Минимальное влияние на latency. |
| **Read Repair**                       | Фоновая проверка и выравнивание консистентности при чтении   | `products_cache_by_region`, `orders_by_user`              | Подходит для часто читаемых данных; согласованность выравнивается постепенно, без блокировки.                                             |
| **Anti-Entropy Repair (Full Repair)** | Периодическая полная синхронизация между нодами              | `order_history_by_region`, `orders_by_user` (раз в сутки) | Для больших наборов данных и аналитики; предотвращает накопление расхождений между репликами. Высокая нагрузка, выполняется в off-peak.   |

#### Репликация и consistency-levels

| Тип данных                   | Репликация                               | Consistency Level                  | Комментарий                                                      |
| ---------------------------- | ---------------------------------------- | ---------------------------------- | ---------------------------------------------------------------- |
| **orders**                   | `NetworkTopologyStrategy {DC1:3, DC2:3}` | `LOCAL_QUORUM`                     | Баланс между доступностью и согласованностью.                    |
| **carts_active**             | `{DC1:2}`                                | `ONE` / `LOCAL_ONE`                | Главное — низкая задержка, допускается eventual consistency.     |
| **products_cache_by_region** | `{DC1:2, DC2:2}`                         | `LOCAL_ONE`                        | Кэш, не критичен к временным расхождениям.                       |
| **order_history_by_region**  | `{DC1:3}`                                | `ANY` при записи, `ONE` при чтении | Пишется часто, читается редко; допускается eventual consistency. |
