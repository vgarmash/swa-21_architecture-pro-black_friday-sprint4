### <a name="_b7urdng99y53"></a>**Название задачи:**
ADR-009: Настройка чтения с реплик и консистентность данных
### <a name="_hjk0fkfyohdk"></a>**Автор:**
Архитектурная команда "Мобильный мир"
### <a name="_uanumrh8zrui"></a>**Дата:**
26.09.2025
#### Контекст и описание проблемы
После внедрения шардирования и репликации MongoDB для онлайн-магазина "Мобильный мир" необходимо оптимизировать стратегию чтения данных. Каждый шард теперь представляет собой replica set с primary узлом для записи и secondary узлами для чтения. Требуется определить, какие операции могут безопасно читать данные с secondary реплик без риска для бизнес-логики.

### <a name="_qmphm5d6rvi3"></a>**Решение**

#### Таблица распределения операций чтения
| Коллекция | Операция чтения                               | Primary/Secondary | Допустимая задержка репликации | Обоснование                                                                 |
|-----------|-----------------------------------------------|-------------------|--------------------------------|-----------------------------------------------------------------------------|
| products  |                                               |                   |                                |                                                                             |
|           | Просмотр каталога товаров                     | Secondary         | До 5 секунд                    | Некритична небольшая задержка в отображении новых товаров или изменений цен |
|           | Поиск и фильтрация товаров                    | Secondary         | До 5 секунд                    | Пользователи допускают небольшую задержку в поисковой выдаче                |
|           | Проверка остатков перед добавлением в корзину | Primary           | 0 секунд                       | Критично для предотвращения overselling                                     |
|           | Отображение товара на странице продукта       | Secondary         | До 3 секунд                    | Базовая информация может быть слегка устаревшей                             |
|           | Проверка остатков при оформлении заказа       | Primary           | 0 секунд                       | Необходима актуальная информация для финальной проверки                     |
| orders    |                                               |                   |                                |                                                                             |
|           | Просмотр истории заказов пользователем        | Secondary         | До 10 секунд                   | История заказов не требует мгновенной консистентности                       |
|           | Отображение статуса текущего заказа           | Primary           | 0 секунд                       | Пользователь ожидает актуальный статус своего заказа                        |
|           | Получение деталей заказа для обработки        | Primary           | 0 секунд                       | Критично для корректной обработки заказа                                    |
|           | Аналитические отчёты по заказам               | Secondary         | До 30 секунд                   | Аналитика допускает задержку для снижения нагрузки                          |
|           | Проверка существования заказа при оплате      | Primary           | 0 секунд                       | Критично для процесса оплаты                                                |
| carts     |                                               |                   |                                |                                                                             |
|           | Получение содержимого корзины                 | Primary           | 0 секунд                       | Пользователь ожидает видеть актуальное состояние корзины                    |
|           | Проверка существования корзины                | Primary           | 0 секунд                       | Важно для корректной работы сессии                                          |
|           | Слияние гостевой корзины                      | Primary           | 0 секунд                       | Требуется консистентность при авторизации                                   |
|           | Очистка старых корзин (TTL)                   | Secondary         | До 60 секунд                   | Фоновая операция, допускает задержку                                        |


Далее приводится обоснование выбора для коллекций products, orders и carts:

#### 1. Коллекция products
Операции, допускающие чтение с secondary:
* Просмотр каталога и поиск: эти операции составляют ~70% всех запросов. Небольшая задержка (3-5 секунд) допустима, так как:
  * Изменения цен и описаний происходят относительно редко (несколько раз в день)
  * Пользователи не заметят задержку в несколько секунд при просмотре каталога
  * Значительно снижается нагрузка на primary узлы

Операции, требующие primary:
* Проверка остатков при покупке: критично для предотвращения продажи отсутствующего товара
* Риск overselling может привести к отмене заказов и недовольству клиентов
* Остатки обновляются часто (при каждой покупке)

#### 2. Коллекция orders
Операции, допускающие чтение с secondary:
* История заказов: задержка до 10 секунд допустима, так как:
* Пользователи редко просматривают историю сразу после оформления заказа
* Это не влияет на бизнес-процессы

Операции, требующие primary:
* Текущий статус заказа: пользователи ожидают видеть актуальный статус
* Особенно критично при статусах "оплачен", "отменён"
* Влияет на доверие к сервису

#### 3. Коллекция carts
Все операции требуют primary**, так как:
* Корзина - это активная рабочая область пользователя
* Любая задержка может привести к путанице (добавил товар, но не вижу)
* Частота обновлений очень высокая
* Объём данных относительно небольшой

### Конфигурация Read Preference в MongoDB

```shell
// Для операций с secondary чтением
db.products.find().readPref("secondaryPreferred", {
  maxStalenessSeconds: 5
})

// Для критичных операций
db.products.find({_id: productId}).readPref("primary")

// Настройка на уровне коллекции для orders
db.orders.find({
  customer_id: userId,
  created_at: {$lt: new Date(Date.now() - 60000)} // заказы старше минуты
}).readPref("secondary", {
  maxStalenessSeconds: 10
})

// Корзины всегда с primary
db.carts.find().readPref("primary")
```

### Мониторинг консистентности

```shell
// Метрика отставания репликации
db.adminCommand({
  replSetGetStatus: 1
}).members.forEach(member => {
  if(member.stateStr === "SECONDARY") {
    const lag = member.optimeDate - member.lastHeartbeat;
    if(lag > 5000) { // более 5 секунд
      alert(`High replication lag: ${lag}ms on ${member.name}`);
    }
  }
})
```

#### Преимущества выбранного решения

* Снижение нагрузки на primary узлы до 60%
* Повышение общей производительности системы
* Сохранение критически важной консистентности данных
* Масштабируемость чтения через добавление secondary узлов

### <a name="_bjrr7veeh80c"></a>**Альтернативы**
Здесь описаны наиболее важные альтернативные решения:

| **Альтернатива**                                      | **Описание**                                                                                                                                                                              | **Причина отказа**                                                                                                                                                                                                                                 |
|:------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Все операции на primary                               | Простейший подход, при котором все операции чтения и записи направляются только на primary узлы. Обеспечивает полную консистентность данных без необходимости управления Read Preference. | Простота реализации, но не решает проблему масштабирования                                                                                                                                                                                         |
| Все некритичные операции на secondary                 | Радикальный подход с максимальным использованием secondary реплик для всех операций, кроме записи. Все операции чтения, независимо от их критичности, направляются на secondary узлы.     | Риск показа сильно устаревших данных                                                                                                                                                                                                               |
| Использование отдельного кеша (Redis)                 | Внедрение дополнительного слоя кеширования через Redis для часто запрашиваемых данных. Кеш обновляется асинхронно при изменениях в MongoDB, читающие операции сначала обращаются к кешу.  | Дополнительная сложность и затраты на инфраструктуру                                                                                                                                                                                               |
| Разделение на отдельные БД для чтения и записи        | Создание выделенных кластеров MongoDB: один для записи (master), другой для чтения (slave) с односторонней репликацией. Приложение явно выбирает кластер в зависимости от типа операции.  | Удвоение инфраструктурных затрат. Сложность поддержания консистентности между кластерами. Необходимость дополнительных механизмов синхронизации. Потеря преимуществ встроенной репликации MongoDB.                                                 |
| Использование Change Streams для eventual consistency | Применение MongoDB Change Streams для асинхронного обновления материализованных представлений данных, оптимизированных для чтения. Клиенты читают из этих представлений.                  | Существенная задержка в распространении изменений. Дополнительное хранилище для материализованных представлений. Сложность поддержки консистентности между исходными данными и представлениями. Не подходит для операций, требующих свежих данных. |

**Недостатки, ограничения, риски**

* Усложнение логики приложения
* Необходимость тщательного мониторинга lag репликации
* Риск показа устаревших данных при сбоях репликации
* Требуется обучение разработчиков правильному использованию Read Preference
