# Проектирование схем коллекций для шардирования данных

## Схемы коллекций

### orders (Заказы)

```json
{
  "id": {
    "type": "uuid",
    "description": "Уникальный идентификатор заказа"
  },
  "user_id": {
    "type": "uuid",
    "description": "Идентификатор клиента"
  },
  "created_at": {
    "type": "date-time",
    "description": "Дата-время оформления заказа"
  },
  "status": {
    "type": "string",
    "description": "Статус заказа",
    "values": ["created", "confirmed", "cancelled", "delivering", "completed"]
  },
  "geozone": {
    "type": "string",
    "description": "Геозона заказа",
    "values": ["moscow", "stpetersburg", "yekaterinburg", "..."]
  },
  "total": {
    "type": "number",
    "description": "Сумма заказа"
  },
  "items": {
    "type": "array",
    "description": "Список заказанных товаров",
    "data": {
      "product_id": {
        "type": "uuid",
        "description": "Уникальный идентификатор товара"
      },
      "quantity": {
        "type": "number",
        "description": "Количество товара в заказе"
      }
    }
  }
}
```

#### Основные операции поиска:

* Поиск заказов конкретного пользователя

### products (Товары)

```json
{
  "id": {
    "type": "uuid",
    "description": "Уникальный идентификатор товара"
  },
  "name": {
    "type": "string",
    "description": "Наименование товара"
  },
  "category": {
    "type": "string",
    "description": "Категория товара",
    "values": ["phone", "tablet", "laptop", "..."]
  },
  "price": {
    "type": "number",
    "description": "Цена товара"
  },
  "stocks": {
    "type": "array",
    "description": "Остаток товара в каждой геозоне",
    "data": {
      "geozone": {
        "type": "string",
        "description": "Геозона",
        "values": ["moscow", "stpetersburg", "yekaterinburg", "..."]
      },
      "quantity": {
        "type": "number",
        "description": "Остаток товара в геозоне"
      }
    }
  },
  "attributes": {
    "type": "array",
    "description": "Дополнительные атрибуты",
    "data": {
      "attribute_name": {
        "type": "string",
        "description": "Наименование атрибута",
        "values": ["color", "size", "..."]
      },
      "attribute_value": {
        "type": "string",
        "description": "Значение атрибута"
      }
    }
  }
}
```

#### Основные операции поиска:

* Поиск товаров по категориям
* Фильтрация по диапазону цен

### carts (Корзины)

```json
{
  "id": {
    "type": "uuid",
    "description": "Уникальный идентификатор корзины"
  },
  "user_id": {
    "type": "uuid",
    "description": "Идентификатор пользователя"
  },
  "session_id": {
    "type": "uuid",
    "description": "Идентификатор сессии (для незарегистрированных пользователей)"
  },
  "status": {
    "type": "string",
    "description": "Статус корзины",
    "values": ["active", "ordered", "abandoned"]
  },
  "created_at": {
    "type": "date-time",
    "description": "Дата-время создания"
  },
  "updated_at": {
    "type": "date-time",
    "description": "Дата-время последнего обновления"
  },
  "expires_at": {
    "type": "date-time",
    "description": "Дата-время очистки корзины (TTL)"
  },
  "items": {
    "type": "array",
    "description": "Список заказанных товаров",
    "data": {
      "product_id": {
        "type": "uuid",
        "description": "Уникальный идентификатор товара"
      },
      "quantity": {
        "type": "number",
        "description": "Количество товара в заказе"
      }
    }
  }
}
```

#### Основные операции поиска:

* Получение текущей корзины для пользователя `user_id` или сессии незарегистрированного пользователя `session_id`

## Выбор ключей и стратегий шардирования

| **Коллекция** | **Стратегия шардирования**                                  | **Обоснование**                                                                                                                                                                                     |
|:-------------:|:------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    orders     | *Хэширование* поля `user_id`                                 | Требуется равномерное распределение между пользователями, так что добавляем хэширование по ключу                                                                                                    |
|   products    | *Хэширование* поля `category`, и *диапазон* по полю `price` | Поскольку часто выполняются запросы по категориям, то требуется хэшировать по этому полю, а также дополнительно разбить шарды по диапазонам цен, поскольку это также частый фильтр внутри категории |
|     carts     | *Хэширование* комбинации полей `user_id` и `session_id`     | Требуется равномерное распределение между пользователями - как зарегистрированными, так и незарегистрированными - поэтому хэширование требуется для комбинации двух полей                           |

**Дополнительно:**

* Для коллекции товаров, возможно, что если пользователи чаще выбирают не фиксированные, а произвольные диапазоны цен, шардирование по диапазону цены избыточно - требуются вводные по тому, как работает фильтр цены.
* Гипотетически, если пользователи более-менее равномерно распределены по стране, возможно сменить стратегию шардирования всех коллекций на геошардирование. Однако, без дополнительных вводных, предполагаем, что есть сильный перевес по заказам техники в сторону Москвы и Санкт-Петербурга, что делает геошардирование неоптимальным.

# Выявление и устранение «горячих» шардов

## Описание проблемы

Из-за категории «Электроника» произошла перегрузка одного из шардов MongoDB, так как 70% запросов приходилось именно на эти товары. Требуется выявить набор метрик для мониторинга состояния шардов и предложить механизм автоматического перераспределения данных.

## Причина проблемы

Возникновение проблемы связано с выбором стратегии шардирования - с помощью хеширования по полю `category` и диапазонного по полю `price`. Выше описано обоснование выбора такого ключа шардирования.
Однако, в случае, если товаров одной категории в одном ценовом диапазоне непропорционально много (как в данном случае), это может вызвать избыточную нагрузку на один из шардов, на который направляются данные из этой категории.

## Варианты решения

### 1. Перераспределение диапазонов цен

Очевидным выглядит перераспределение диапазонов по полю `category` таким образом, чтобы товары разной цены были распределены по шардам более равномерно.
Например, если значительное число товаров по цене сгруппировано вокруг суммы 50 000 руб., можно сузить диапазоны вокруг этой отметки, и расширить их для сумм, товаров с которыми значительно меньше.

#### Плюсы:

- Наиболее простое и быстрое решение, не требующее больших трудозатрат

#### Минусы:

- Решение неустойчиво в случае часто изменяющихся цен, частых скидок и т.д., когда нагрузка может перераспределиться вновь
- Снизится эффективность запросов с фильтрацией по полю `price`, так как с большей вероятностью придется получать данные из разных шардов.

### 2. Дополнительны ключ шардирования

Следующим вариантом будет введение дополнительного ключа шардирования, т.е. хеширование поля `category` и еще одного поля.

#### Плюсы

- Добавление в хэш-функцию уникального поля (например, `id`) позволит значительно более равномерно распределять нагрузку между шардами.

#### Минусы:

- Снижение скорости выполнения запросов в связи с тем, что теперь потребуется собирать данные для одной категории с разных шардов.

### 3. Введение динамического шардирования

В случае, если есть жесткое требование к скорости выполнения запросов по категориям, возможно внедрение динамического шардирования вместо текущего.

#### Плюсы:

- Наиболее гибкий вариант, который потенциально позволит вообще избавиться от проблем с перегрузкой отдельных шардов.

#### Минусы:

- Очень дорогая и сложная в реализации опция, требующая экспертизы от специалистов по настройке БД и разработчиков.

### Решение

По совокупности факторов наиболее оптимальным выглядит решение 2 с введением дополнительного ключа шардирования.

## Метрики для анализа производительности шардов

### 1. Объем данных на шард

С помощью команды

```javascript
db.collection.getShardDistribution()
```

можно видеть распределение документов в коллекции между шардами и объем данных на каждом шарде.

### 2. Количество операций чтения и записи на шарде

На уровне `mongod` можно собирать количество операций вставки, запроса, обновления и удаления следующими командами:

```javascript
db.serverStatus().opcounters.insert
db.serverStatus().opcounters.query
db.serverStatus().opcounters.update
db.serverStatus().opcounters.delete
```

Таким образом видно будет, какие шарды чаще обрабатывают запросы.

### 3. Задержка запросов к шарду

Аналогично можно посмотреть для каждого шарда и сравнить, насколько долго выполняются операции на нем, с помощью команд:

```javascript
db.serverStatus().opLatencies.reads.latency
db.serverStatus().opLatencies.writes.latency
```

Так можно вычислить шарды, которые отвечают дольше и, скорее всего, перегружены.

### 4. Визуализация метрик

Если на это есть ресурсы, рекомендуется с помощью экспорта данных (`mongodb_exporter`) и связки Prometheus + Grafana организовать визуальным мониторинг таких метрик, как:

```javascript
mongodb_mongod_op_latencies_latency_seconds // время выполнения операций в секундах
mongodb_mongod_connections_current // число активных соединений
```

и другие.
