# Проектирование схем коллекций для шардирования данных

## Products

Коллекция ``products`` хранит сведения о товарах:

```JSON
{
    "_id": "672a1b2c3d4e5f6a7b8c9d0e",
    "name": "Телевизор 32``",
    "category": "Телевизоры",
    "price": 12000.0,
    "attributes": {
        "color": "Чёрный",
        "size": "32``"
    },
    "stock_by_s": {
        "MSK": 34,
        "SPB": 12
    },
    "created_at": "2025-11-05T12:34:56Z",
    "updated_at": "2025-11-05T12:34:56Z"
}
```

## Рекомендации по индексам

- ``_id`` - уже индексирован по-умолчанию;
- ``category`` - для поиска по категориям;
- ``price`` - для фильтрации по диапазону цен.
  
Создание индексов:

```
db.products.createIndex({ category: 1 })
db.products.createIndex({ price: 1 })
db.products.createIndex({ category: 1, price: 1 })
```

## Операции

- Добавление товара:
    ```mongosh
    db.products.insertOne({
        _id: ObjectId("672a1b2c3d4e5f6a7b8c9d0e"),
        name: "Телевизор 32``",
        category: "Телевизоры",
        price: 12000.00,
        stock_by_zone: { "MSK": 34, "SPB": 12 },
        attributes: { color: "Чёрный", size: "32``" },
        created_at: new Date(),
        updated_at: new Date()
    })
    ```
- Поиск товара по категории и цене:
    ```
    db.products.find({
        category: "Телевизоры",
        price: { $gte: 10000, $lte: 20000 }
    })
  ```
- Списание остатка по товару (в рамках транзакции):
    ```
    db.products.updateOne(
        { 
            _id: ObjectId("17fa191e810c19729de860ea"),
            "stock_by_zone.MSK": { $gte: 2 }
        },
        { 
            $inc: { "stock_by_zone.MSK": -2 },
            $set: { updated_at: new Date() }
        }
    )
    ```

## Шардирование

Характеристика коллекции:

- Относительно небольшой объём данных (тысячи-десятки тысяч товаров);
- Частые чтения (поиск по категории и цене, получени данных для карточки товара);
- Частые записи (обновление остатков товаров) - критичны по производительности и атомарности;
- Критична консистентность остатков;
- Часто запрашивается по категориям, но это не уникальные записи - низкая селективность.

Шардировать коллекцию не имеет смысла:

- Объём данных небольшой и легко поместится на один реплика-сет;
- Шардирование создаст дополнительные накладные расходы, что при таком объёме данных нецелесообразно.

В дальнейшем с ростом количества товаров можно использовать хэш-шардирование по ``_id`` - равномерно распределит товары, однако при работе пользователя с корзиной приведёт к запросам по всем шардам.

# Orders

Коллекция ``orders`` включает заказы клиентов

```JSON
{
    "_id": "17fa191e810c19729de860ea",
    "user_id": "46fa191e814f19729de860ea",
    "order_date": "2025-11-05T12:34:56Z",
    "status": "confirmed", // Например: "pending", "confirmed", "shipped", "delivered", "cancelled"
    "amount": 12000.0,
    "geo_zone": "MSK",
    "items": [
        {
            "product_id": "672a1b2c3d4e5f6a7b8c9d0e",
            "name": "Телевизор 32``",
            "price": 12000.0,
            "quantity": 1,
            "geo_zone": "MSK"
        }
    ]
}
```

## Рекомендации по индексам

- ``_id`` - уже индексирован по-умолчанию;
- ``user_id`` - для поиска истории заказов по пользователю;
- ``status`` - для поиска заказов по статусам для их обработки;
- ``{ user_id: 1, order_date: -1 }`` - для сортировки заказов по времени;
- ``geo_zone`` - для аналитики по гео-зонам.

Создание индексов:
```
db.orders.createIndex({ user_id: 1 })
db.orders.createIndex({ status: 1 })
db.orders.createIndex({ user_id: 1, order_date: -1 })
db.orders.createIndex({ geo_zone: 1 })
```

## Операции

- Создание заказа:
    ```
    db.orders.insertOne({
        _id: ObjectId("17fa191e810c19729de860ea"),
        user_id: ObjectId("46fa191e814f19729de860ea"),
        order_date: new Date(),
        items: [
            {
            product_id: ObjectId("672a1b2c3d4e5f6a7b8c9d0e"),
            name: "Телевизор 32``",
            price: 12000.00,
            quantity: 1,
            geo_zone: "MSK"
            }
        ],
        status: "confirmed",
        total_amount: 12000.00,
        geo_zone: "MSK",
        created_at: new Date()
    })
    ```
- Получение истории заказов для пользователя:
    ```
    db.orders.find({
        user_id: ObjectId("46fa191e814f19729de860ea")
    }).sort({ order_date: -1 })
    ```

## Шардирование

Характеристика коллекции:

- Очень большой объём данных и растёт линейно/экспоненциально с числом пользователей;
- Записи часто добавляются, но изменяются редко (только статусы);
- Частые запросы по ``user_id`` (история заказов), реже запросы по ``status`` и ``geo_zone``;
- Требуется высокая пропускная способность на запись - оформление заказов.

Целесообразно использовать шардирование для распределения нагрузки записи коллекций. Используется хэш-шардирование по ``user_id``, что позволяет:

- Равномерно распределить данные. Чем больше пользователей - тем более равномерно будут распределены данные;
- Обеспечить локальность данных по пользователю на операциях чтения - все заказы одного пользователя хранятся на одном шарде;
- Избежать монопольных шардов, например, в случае использования диапазонного ключа по ``order_date``.

# Carts

Коллекция ``carts`` хранит данные о текущих корзинах (как гостевых, так и пользовательских)

```JSON
{
    "_id": "17fa191e810c19729de860ea",
    "owner_id": "46fa191e814f19729de860ea",         // id пользователя или сессии гостя (например, "sess_46fa191e814f19729de860ea")
    "type": "user",                                 // тип корзины - user, guest
    "datetime": "2025-11-05T12:34:56Z",
    "status": "active",                             // "active", "ordered", "abandoned"
    "amount": 12000.0,
    "geo_zone": "MSK",
    "items": [
        {
            "product_id": "672a1b2c3d4e5f6a7b8c9d0e",
            "name": "Телевизор 32``",
            "price": 12000.0,
            "quantity": 1,
            "geo_zone": "MSK"
        }
    ],
    "created_at": "2025-11-05T12:34:56Z",
    "updated_at": "2025-11-05T12:34:56Z",
    "expires_at": "2025-11-12T10:00:00Z"        // TTL через 7 дней
}
```

## Рекомендации по индексам

- ``_id`` - уже индексирован по-умолчанию;
- ``{ owner_id: 1, status: 1 }`` — для поиска корзины по пользователям и гостям;
- ``expires_at`` — TTL-индекс для автоматической очистки:
    ```mongosh
    db.carts.createIndex({ "expires_at": 1 }, { expireAfterSeconds: 0 })
    ```

Создание индексов:
```
db.carts.createIndex({ owner_id: 1, status: 1 })
db.carts.createIndex({ expires_at: 1 }, { expireAfterSeconds: 0 })
```

## Операции

- Создание корзины гостя:
    ```
    db.carts.insertOne({
        owner_id: "sess_46fa191e814f19729de860ea",
        type: "quest",
        items: [],
        status: "active",
        created_at: new Date(),
        updated_at: new Date(),
        expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    })
    ```
- Создание корзины авторизованного пользователя:
    ```
    db.carts.insertOne({
        owner_id: ObjectId("46fa191e814f19729de860ea"),
        type: "user",
        items: [],
        status: "active",
        created_at: new Date(),
        updated_at: new Date(),
        expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    })
    ```
- Получение корзины:
  ```mongosh
    // Для пользователя
    db.carts.findOne({ owner_id: "sess_46fa191e814f19729de860ea", status: "active" })

    // Для гостя
    db.carts.findOne({ owner_id: "46fa191e814f19729de860ea", status: "active" })
  ```
- Добавление товара в корзину:
    ```
    db.carts.updateOne(
        {
            _id: ObjectId("17fa191e810c19729de860ea"),
            "items.product_id": { $ne: ObjectId("672a1b2c3d4e5f6a7b8c9d0e") }
        },
        {
            $push: {
            items: { product_id: ObjectId("672a1b2c3d4e5f6a7b8c9d0e"), quantity: 1 }
            },
            $set: { updated_at: new Date() }
        }
    )
    ```
- Обновление существующего товара в корзине:
    ```
    db.carts.updateOne(
        {
            _id: ObjectId("17fa191e810c19729de860ea"),
            "items.product_id": ObjectId("672a1b2c3d4e5f6a7b8c9d0e")
        },
        {
            $inc: { "items.$.quantity": 1 },
            $set: { updated_at: new Date() }
        }
    )
    ```
- Изменение статуса пользовательской корзины:
    ```
    db.carts.updateOne(
        { _id: ObjectId("17fa191e810c19729de860ea") },
        { 
            $set: { 
            status: "abandoned", 
            updated_at: new Date() 
            } 
        }
    )
    ```

## Шардирование

Характеристика коллекции:

- Высокая частота записи - добавление/удаление товаров, обновление корзин;
- Короткий жизненный цикл (TTL - 7 дней);
- Данные привязаны либо к пользователю, либо к гостю - ``owner_id``;
- Коллекция может быть очень большой при высокой посещаемости.

Шардирование в данной ситуации позволит разделить нагрузку на чтение/запись данных по шардам.
В качестве стратегии используется хэш-шардирование по ``owner_id`` (каждая корзина уникальна по ``owner_id`` и может использоваться в качестве ключа). Такой подходи позволит:
- Равномерно распределить хранение корзин пользователей и гостей по шардам (особенно учитывая количество данных коллекции);
- Обеспечить локальность даных по пользователям - хранение корзин зарегистрированных пользователей в том же шарде что и заказы пользователя;
- Выполнять чтение за 1 запрос (сетевой), поскольку данные на одном шарде;
- Поддерживает слияние корзин - гостевая корзина и пользовательская корзина, возможно, находятся на разных шардах и она может выполняться за несколько сетевых запросов (но операция редкая).


# Выявление и устранение «горячих» шардов

## Метрики состояния шардов

Перегрузка одного из шардов произошла из-за категории "Электроника", а значит при шардировании коллекции ``products`` использовался ключ по ``category``. Ключи с низкой кардинальностью и неравномерным распределением данных могу стать причиной "горячих" шардов.

Для отслеживания состояния шардов можно настроить сбор следующих метрик:

|   | Метрика | Описание |  Порог | Комментарий |
|--|--|--|--|--|
| 1 | ``shard_cpu_utilization`` | Процент использования CPU на MongoDB-ноде | >70% на одном шарде при <30% на других | Прямой индикатор перекоса в нагрузке по CPU по шардам |
| 2 | ``shard_disk_io_utilization`` | Процент времени, в течение которого диск занят (ввод-вывод) | >80% длительное время | Стабильно высокая нагрузка на диск по сравнению с другими шардами |
| 3 | ``shard_opcounters.insert/update/query`` | Количество операций в секунду по типам | Разница >3x между шардами | Неравномерная нагрузка между шардами на уровне операций |
| 4 | ``shard_network_bytes_in/out`` | Скорость передачи данных (вход/выход) на ноду | Аномальный рост на одном шарде | Явная ассиметрия в значениях между шардами может указывать на "горячий" шард |
| 5 | ``chunk_count_per_shard`` | Количество чанков, закрепленных за каждым шардом | Отклонение > ±30% от среднего | Дисбаланс в количестве чанков по шардам.|
| 6 | ``jumbo_chunk_count`` | Количество чанков, превысивших лимит chunkSize | >0 | Количество чанков, превысивших лимит chunkSize (по умолчанию 64 МБ) и не подлежащих автоматическому разбиению. Один jimbo-чанк с category "Электроника" - прямая причина "горячего" шарда. |
| 7 | ``avg_chunk_size_bytes`` | Средний размер чанка на шард (в байтах) | >64 МБ (или близко к ``chunkSize``) | Признак "тяжёлых" чанков |
| 8 | ``shard_latency_95`` | Время выполнения операций (read/write) на каждом шарде — 95% запросов укладываются в это время | Разница >3x между шардами | Явное отличие в latency одного из шардов может являться признаком hot shard |

## Механизмы автоматического перераспределения данных

### Настройка балансировщика с увеличенной частотой проверки и агрессивной миграцией

Для того чтобы заставить балансировщик быстрее реагировать на дисбаланс:
- Включить балансировку 24/7 (если ограничена по времени);
- Уменьшить порог срабатывания: мигрировать при разнице ≥1 чанка (по умолчанию — 2 чанка для small shards, 8 — для large)
- Отключить ожидание реплик (ускоряет миграцию, но снижает durability)
- Убедиться, что балансировщик включён

Сделать это можно скриптом:

```bash
use somedb

// Включить балансировку 24/7
db.settings.updateOne(
  { _id: "balancer" },
  { $set: { 
      activeWindow: { start: "00:00", stop: "23:59" }
    } 
  },
  { upsert: true }
)

// Уменьшить порог срабатывания
db.settings.updateOne(
  { _id: "balancer" },
  { $set: { migrationThreshold: 1 } },
  { upsert: true }
)

// Отключить ожидание реплик
db.settings.updateOne(
  { _id: "balancer" },
  { $set: { secondaryThrottle: false } },
  { upsert: true }
)

// Убедиться, что балансировщик включён
sh.setBalancerState(true)
```

### Сокращение размера чанка и инициализация перераспределения

Чтобы балансировщик смог равномернее распределить чанки нужно создать больше мелких чанков.

1. Уменьшить максимальный размер чанка до 32 МБ (вместо 64 МБ по умолчанию):

    ```bash
    use somedb
    db.settings.updateOne(
    { _id: "chunksize" },
    { $set: { value: 32 } },
    { upsert: true }
    )
    ```

    Проверка установленного размера:
    ```bash
    db.settings.findOne({ _id: "chunksize" })
    ```

    Вывод:
    ```bash
    { "_id": "chunksize", "value": 32 }
    ```

2. Принудительно запустить балансировку (если она не активна)

    ```bash
    sh.startBalancer()
    ```

    Проверить, что балансировщик работает
    ```bash
    sh.isBalancerRunning()
    ```

> Уменьшение ``chunkSize`` влияет только на новые чанки. Существующие крупные чанки не разобьются автоматически — их нужно разбивать вручную.

### Проверка чанков по ключу, разбиение большого чанка и перемещение на другой шард

Большие чанки могут содержать категорию "Электроника", к которой идёт много запросов и изменения коллекций. Можно выделить категорию в отдельный чанк и перенести на другой, менее загруженный, шард.

1. Поиск чанков по значению ключа

    ```bash
    use somedb

    db.chunks.find({
    ns: "somedb.products",
    "min.category": { $lte: "Электроника" },
    "max.category": { $gte: "Электроника" }
    }, {
    shard: 1,
    min: 1,
    max: 1,
    jumbo: 1,
    _id: 0
    })
    ```

    Пример вывода результата выполнения скрипта:
    ```bash
    {
    "shard": "shard1",
    "min": { "category": "Бытовая техника" },
    "max": { "category": "Книги" },
    "jumbo": true
    }
    ```

2. Разбить большой чанк на части

    ```bash
    use somedb

    sh.splitAt("somedb.products", { category: "Бытовая техника" })
    sh.splitAt("somedb.products", { category: "Электроника" })
    sh.splitAt("somedb.products", { category: "Книги" })
    ```

    После выполнения скрипта один чанк будет разбит на 3.

3. Переместить часть чанков на другой шард

    Этим скриптом переносим чанк с категорией "Электроника" на ``shard2``:
    ```bash
    sh.moveChunk(
    "somedb.products",
    { category: "Электроника" },
    "shard2"
    )
    ```

## Изменение ключа шардирования

Вариантом решения проблемы может стать отказ от шардирования по ``category`` в пользу шардирования по ``_id``. Перешардировать в MongoDB невозможно напрямую требуется выполнить несколько шагов:

1. Создание новой коллекции с хэш-шардированием по ``_id``
    
    ```bash
    sh.enableSharding("somedb")
    sh.shardCollection("somedb.products_new", { _id: "hashed" })
    ```

2. Перенос данных (в фоне, порциями)

    ```bash
    db.products.find().forEach(doc => {
    db.products_new.insertOne(doc)
    })
    ```

3. Замена имён коллекций

    ```bash
    db.products.renameCollection("products_old")
    db.products_new.renameCollection("products")
    ```

# Настройка чтения с реплик и консистентность

## Коллекция ``products``

Частота обновлений:

- Редко: изменение названия, категории, цены;
- Часто: обновление остатков (``stock_by_zone``) — при каждом оформлении заказа.

Операции чтения:

| Операция | Режим чтения | Допустимая задержка | Обоснование |
|--|--|--|--|
| Поиск товаров по категории / фильтрация по цене (каталог, поиск) | Secondary | <2c | Поскольку данные (название, цена, категория) редко меняются, небольшая задержка незаметна пользователю. А чтение с Secondary снижает нагрузку на primary. |
| Просмотр страницы товара (описание, атрибуты) | Secondary | <2c | Метаинформация товаров стабильна. Даже при изменении — пользователь не заметит устаревшего описания 10-секундной давности. |
| Получение остатков перед добавлением в корзину | Primary | 0c | Критично! Если прочитать устаревший остаток (например, 5 вместо 0), пользователь добавит товар в корзину, но при оформлении получит ошибку: «Товар закончился» |
| Проверка остатка при оформлении заказа | Primary | 0c | Операция - часть атомарной операции (проверка -> списание), в которой требуется линейная консистентность. Не может читаться с secondary — иначе race condition. |

## Коллекция ``orders``

Частота обновлений:

- Только добавление новых заказов;
- Редкие обновления: изменение ``status``.

Операции чтения:

| Операция | Режим чтения | Допустимая задержка | Обоснование |
|--|--|--|--|
| Просмотр истории заказов пользователя | Secondary | <2c | Пользователь ожидает увидеть актуальный статус, но задержака до 2 секунд не критична |
| Просмотр истории заказов пользователя после создания заказа | Primary | 0c | Сразу после создания нового заказа получать данные только с Primary, иначе пользователь может наблюдать "исчезновение" заказа |
| Просмотр деталей конкретного заказа | Secondary | <2с | Задержка до 2 секунд в обновлении статуса заказа не критична при просмотре карточки заказа |
| Просмотр деталей конкретного заказа после создания | Primary | 0c | После создания заказа читать нужно с Primary, чтобы избежать "исчезновения" заказа |
| Обработка заказов | Primary | 0c | При обработке заказа критична работа с актуальным статусом, иначе есть риск дублирования операций |
| Получение данных для аналитики | Secondary | <1мин | Для аналитики данные агрегируются за период и задержки репликации не так критичны |

## Коллекция ``carts``

Частота обновлений:

- Очень высокая: добавление/удаление товаров, обновление количества
- TTL-очистка — фоновая

Операции чтения:

| Операция | Режим чтения | Допустимая задержка | Обоснование |
|--|--|--|--|
| Получение текущей корзины пользователя/гостя | Primary | 0c | Критично получение только самых свежих данных, иначе пользователь может увидеть не полную корзину |
| Получение текущей корзины пользователя/гостя перед изменением | Primary | 0c | Критично, иначе есть риск потери товара при чтении не свежих данных |
| Получение списка брошенных, ``abandoned`` корзин | Secondary | <1мин | Работа с брошенными корзинами проводится в фоновом режиме, поэтому задержки репликации не критичны |

# Миграция на Cassandra: модель данных, стратегии репликации и шардирования

## Оценка сущностей интернет-магазина

| Сущность | Требования | Перенос в Cassandra | Обоснование |
|--|--|--|--|
| ``carts`` | — Высокая частота записи<br> — Низкая долговечность (TTL 7 дн.) <br> — Простая структура (ключ -> {items}) <br> — Нет сложных запросов | Да | - Подходит под модель ключ-значение <br> Можно использовать TTL в таблицах <br> - Работа с корзиной происходит только по ключу |
| ``orders`` | - Высокая частота записи <br> - Чтение только по user_id или по order_id <br> Данные immutable после создания (за исключением ``status``) | Да | - Заказы только добавляются (обновление только ``status``) <br> - Изменение статусов можно хранить как отдельные строки (time-series) <br> - Георезервирование критичнодля отказоустойчивости |
| ``products`` | - Редкая запись, частое чтение<br> - Требуется строгая консистентность остатков <br> - Поиск по категории/цене | Нет | - Поиск по вторичным свойствам товара <br> - Частое и конкурирующее обновление остатков (риск hot partition по product_id) <br> - Лучше оставить в MongoDB |
| ``users`` | - Редкие чтение/запись профиля пользователя | Да | - Лучше оставить в документной БД MongoDB |
| ``sessions`` | - Высока частота записи сессий, но короткое время жизни | Да | - Сессии отлично подходят под модель ключ-значение <br> - Управление TTL на уровне таблиц |

Итоговый набор для миграции в Cassandra:

- ``carts`` - самая критичная для latency и масштабируемости;
- ``orders`` - высокая нагрузка записи, immutable (с учётом статуса);
- ``sessions`` - временные данные, высокая нагрузка записи.

## Концептуальная модель данных в Cassandra

### Таблица ``carts``

Требования к доступу:

- Получить корзину по ``session_id`` или по ``user_id``;
- Обновить/добавить товар в корзине;
- Обновить статус корзины;
- Удалить корзину по TTL.

Корзина для гостей:

```sql
-- Создание таблицы для хранения корзин гостей
CREATE TABLE carts_by_guest (
  session_id TEXT,
  created_at TIMESTAMP,
  updated_at TIMESTAMP,
  expires_at TIMESTAMP,
  items MAP<TEXT, INT>,
  PRIMARY KEY ((session_id), created_at)
) WITH 
  CLUSTERING ORDER BY (created_at DESC) AND
  default_time_to_live = 604800;

-- Запрос корзины гостя
SELECT * FROM carts_by_guest 
WHERE session_id = 'sess_46fa191e814f19729de860ea'
ORDER BY created_at DESC 
LIMIT 1;
```

Корзина для пользователей:

```sql
-- Создание таблицы для хранения корзин пользователей
CREATE TABLE carts_by_user (
  user_id UUID,
  created_at TIMESTAMP,
  updated_at TIMESTAMP,
  items MAP<TEXT, INT>,
  PRIMARY KEY ((user_id), created_at)
) WITH 
  CLUSTERING ORDER BY (created_at DESC) AND
  default_time_to_live = 604800;

-- Запрос корзины пользователя
SELECT * FROM carts_by_user 
WHERE user_id = '9b6a936a-fa36-4b92-a820-43f5ffbad28f'
ORDER BY created_at DESC 
LIMIT 1;
```

### Таблица ``order``

Требования к доступу:

- Создать заказ (запись в таблицу);
- Получить заказ по ``order_id``;
- Получить историю заказов по ``user_id`` (сортировка по дате);
- Отобразить статус (часто обновляется).

Таблица ``orders`` - хранение основных данных по заказам:

```sql
CREATE TABLE orders (
  order_id UUID,
  user_id UUID,
  order_date TIMESTAMP,
  items LIST<FROZEN<MAP<TEXT, TEXT>>>,
  status TEXT,
  total_amount DECIMAL,
  geo_zone TEXT,
  PRIMARY KEY ((order_id))
);
```

Таблица ``orders_by_user`` - хранение истории заказов по пользователям:

```sql
CREATE TABLE orders_by_user (
  user_id UUID,
  order_date TIMESTAMP,
  order_id UUID,
  status TEXT,
  total_amount DECIMAL,
  geo_ TEXT,
  PRIMARY KEY ((user_id), order_date)
) WITH CLUSTERING ORDER BY (order_date DESC);
```

Таблица ``order_status_history`` - таблица для статус-трекинга по заказам
```sql
CREATE TABLE order_status_history (
  order_id UUID,
  status_date TIMESTAMP,
  status TEXT,
  operator TEXT,
  PRIMARY KEY ((order_id), status_date)
) WITH CLUSTERING ORDER BY (status_date DESC);
```

При такой модели данных в Cassandra получаем:

- Равномерное распределение по ``order_id`` и ``user_id`` (UUID).
- Чтение истории заказа происходит из одной партиции, отсортированной по дате.
- Обновление статуса - добавление записи в таблицу (не update). Для получения актуального статуса достаточно выбрать последнюю запись. В отдельной таблице хранится история изменения статусов заказов.

### Таблица ``user_sessions``

Требования:

- Быстрая проверка валидности refresh-токена.
- TTL (обычно 30 дней).

Таблица user_sessions - хранение сессий пользователей с TTL 30 дней

```sql
CREATE TABLE user_sessions (
  user_id UUID,
  refresh_token_hash TEXT,
  issued_at TIMESTAMP,
  expires_at TIMESTAMP,
  ip_address INET,
  user_agent TEXT,
  PRIMARY KEY ((user_id), refresh_token_hash)
) WITH 
  default_time_to_live = 2592000; -- 30 дней
```

Такая модель позволит обеспечить автоматическую чистку устаревший сессий, а так же обеспечить равномерность распределения по ``user_id``.

## Стратегии обеспечения целостности данных

Consistency level (**CL**) в Apache Cassandra — это настройка, которая определяет, сколько подтверждений должен получить координатор, чтобы сообщить пользователю, что его запрос завершён успешно. 

В Cassandra существуют следующие уровни согласованности:

- **ANY** — даёт возможность записать данные, даже если все узлы-реплики не отвечают. Координатор дожидается первого ответа от любого одного узла-реплики или данные сохранятся с помощью механизма направленной отправки (hinted handoff) на координаторе.
- **ONE, TWO, THREE** — координатор шлёт запросы всем узлам-репликам, но возвращает управление пользователю, дождавшись подтверждения от 1,2 или 3 узлов соответственно.
- **QUORUM** — координатор дожидается подтверждения записи от более чем половины узлов-реплик, а именно round(N/2)+1, где N — уровень репликации.
- **LOCAL_QUORUM** — собирается кворум узлов в том датацентре, где происходит координация, и возвращаются данные с последней меткой времени.
- **EACH_QUORUM** — координатор ожидает подтверждения от кворума в каждом из датацентров.

В Cassandra используется несколько режимов восстановления:

- **Hinted Handoff** - если нода в статусе ``down``, то координатор сохраняет hint и отправит позже;
- **Read Repair** - при чтении с CL > ONE координатор сравнивает версии и исправляет отстающие;
- **Anti-Entropy Repair** - фоновое сравнение Merkle trees между репликами.

Выбор стратегий по сущностям:

| Сущность | Consistency level (Запись/Чтение) | Hinted Handoff | Read Repair | Anti-Entropy Repair | Обоснование |
|--|--|--|--|--|--|
| ``carts`` | LOCAL_QUORUM / LOCAL_QUORUM | Включён | Включён | Раз в 7 дней | - Корзина временная, но важна для работы пользователей <br> - LOCAL_QUORUM обеспечивает устойчивость к сбоям на нескольких узлах <br> - Repair компенсирует редкие расхождения (при чтении, а так же раз в 7 дней) | 
| ``orders`` | EACH_QUORUM / QUORUM | Включён | Включён | Раз в 24 часа | - Заказы не обновляются и критичны для бизнеса <br> - EACH_QUORUM гарантирует запись во все датацентры <br> - Ежедневный Repair обеспечивает выравнивание данных | 
| ``user_sessions`` | LOCAL_ONE / LOCAL_QUORUM | Включён | Выключен | Раз в 30 дней | - Сессии временные и допустима потеря данных при аварии <br> - LOCAL_ONE для минимальной latency при логине <br> - Read Repair выключен, чтобы не замедлять аутентификацию |
