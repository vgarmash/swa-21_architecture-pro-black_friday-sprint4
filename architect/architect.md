# Проектирование схем коллекций для шардирования данных

## Products

Коллекция products хранит сведения о товарах:

```JSON
{
    "_id": "672a1b2c3d4e5f6a7b8c9d0e",
    "name": "Телевизор 32``",
    "category": "Телевизоры",
    "price": 12000.0,
    "attributes": {
        "color": "Чёрный",
        "size": "32``"
    },
    "stock_by_zones": {
        "MSK": 34,
        "SPB": 12
    },
    "created_at": "2025-11-05T12:34:56Z",
    "updated_at": "2025-11-05T12:34:56Z"
}
```

## Рекомендации по индексам

- _id - уже индексирован по-умолчанию;
- category - для поиска по категориям;
- price - для фильтрации по диапазону цен.
  
Создание индексов:

```
db.products.createIndex({ category: 1 })
db.products.createIndex({ price: 1 })
db.products.createIndex({ category: 1, price: 1 })
```

## Операции

- Добавление товара:
    ```mongosh
    db.products.insertOne({
        _id: ObjectId("672a1b2c3d4e5f6a7b8c9d0e"),
        name: "Телевизор 32``",
        category: "Телевизоры",
        price: 12000.00,
        stock_by_zone: { "MSK": 34, "SPB": 12 },
        attributes: { color: "Чёрный", size: "32``" },
        created_at: new Date(),
        updated_at: new Date()
    })
    ```
- Поиск товара по категории и цене:
    ```
    db.products.find({
        category: "Телевизоры",
        price: { $gte: 10000, $lte: 20000 }
    })
  ```
- Списание остатка по товару (в рамках транзакции):
    ```
    db.products.updateOne(
        { 
            _id: ObjectId("17fa191e810c19729de860ea"),
            "stock_by_zone.MSK": { $gte: 2 }
        },
        { 
            $inc: { "stock_by_zone.MSK": -2 },
            $set: { updated_at: new Date() }
        }
    )
    ```

## Шардирование

Характеристика коллекции:

- Относительно небольшой объём данных (тысячи-десятки тысяч товаров);
- Частые чтения (поиск по категории и цене, получени данных для карточки товара);
- Частые записи (обновление остатков товаров) - критичны по производительности и атомарности;
- Критична консистентность остатков;
- Часто запрашивается по категориям, но это не уникальные записи - низкая селективность.

Шардировать коллекцию не имеет смысла:

- Объём данных небольшой и легко поместится на один реплика-сет;
- Шардирование создаст дополнительные накладные расходы, что при таком объёме данных нецелесообразно.

В дальнейшем с ростом количества товаров можно использовать хэш-шардирование по _id - равномерно распределит товары, однако при работе пользователя с корзиной приведёт к запросам по всем шардам.



# Orders

Коллекция orders включает заказы клиентов

```JSON
{
    "_id": "17fa191e810c19729de860ea",
    "user_id": "46fa191e814f19729de860ea",
    "order_date": "2025-11-05T12:34:56Z",
    "status": "confirmed",                      // Например: "pending", "confirmed", "shipped", "delivered", "cancelled"
    "amount": 12000.0,
    "zone": "MSK",
    "items": [
        {
            "product_id": "672a1b2c3d4e5f6a7b8c9d0e",
            "name": "Телевизор 32``",
            "price": 12000.0,
            "quantity": 1,
            "zone": "MSK"
        }
    ]
}
```

## Рекомендации по индексам

- _id - уже индексирован по-умолчанию;
- user_id - для поиска истории заказов по пользователю;
- status - для поиска заказов по статусам для их обработки;
- { user_id: 1, order_date: -1 } - для сортировки заказов по времени;
- zone - для аналитики по гео-зонам.

Создание индексов:
```
db.orders.createIndex({ user_id: 1 })
db.orders.createIndex({ status: 1 })
db.orders.createIndex({ user_id: 1, order_date: -1 })
db.orders.createIndex({ zone: 1 })
```

## Операции

- Создание заказа:
    ```
    db.orders.insertOne({
        _id: ObjectId("17fa191e810c19729de860ea"),
        user_id: ObjectId("46fa191e814f19729de860ea"),
        order_date: new Date(),
        items: [
            {
            product_id: ObjectId("672a1b2c3d4e5f6a7b8c9d0e"),
            name: "Телевизор 32``",
            price: 12000.00,
            quantity: 1,
            zone: "MSK"
            }
        ],
        status: "confirmed",
        total_amount: 12000.00,
        zone: "MSK",
        created_at: new Date()
    })
    ```
- Получение истории заказов для пользователя:
    ```
    db.orders.find({
        user_id: ObjectId("46fa191e814f19729de860ea")
    }).sort({ order_date: -1 })
    ```

## Шардирование

Характеристика коллекции:

- Очень большой объём данных и растёт линейно/экспоненциально с числом пользователей;
- Записи часто добавляются, но изменяются редко (только статусы);
- Частые запросы по user_id (история заказов), реже запросы по status и zone;
- Требуется высокая пропускная способность на запись - оформление заказов.

Целесообразно использовать шардирование для распределения нагрузки записи коллекций. Используется хэш-шардирование по user_id, что позволяет:

- Равномерно распределить данные. Чем больше пользователей - тем более равномерно будут распределены данные;
- Обеспечить локальность данных по пользователю на операциях чтения - все заказы одного пользователя хранятся на одном шарде;
- Избежать монопольных шардов, например, в случае использования диапазонного ключа по order_date.

# Carts

Коллекция carts хранит данные о текущих корзинах (как гостевых, так и пользовательских)

```JSON
{
    "_id": "17fa191e810c19729de860ea",
    "owner_id": "46fa191e814f19729de860ea",         // id пользователя или сессии гостя (например, "sess_46fa191e814f19729de860ea")
    "type": "user",                                 // тип корзины - user, guest
    "datetime": "2025-11-05T12:34:56Z",
    "status": "active",                             // "active", "ordered", "abandoned"
    "amount": 12000.0,
    "zone": "MSK",
    "items": [
        {
            "product_id": "672a1b2c3d4e5f6a7b8c9d0e",
            "name": "Телевизор 32``",
            "price": 12000.0,
            "quantity": 1,
            "zone": "MSK"
        }
    ],
    "created_at": "2025-11-05T12:34:56Z",
    "updated_at": "2025-11-05T12:34:56Z",
    "expires_at": "2025-11-12T10:00:00Z"        // TTL через 7 дней
}
```

## Рекомендации по индексам

- _id - уже индексирован по-умолчанию;
- { owner_id: 1, status: 1 } — для поиска корзины по пользователям и гостям;
- expires_at — TTL-индекс для автоматической очистки:
```mongosh
db.carts.createIndex({ "expires_at": 1 }, { expireAfterSeconds: 0 })
```

Создание индексов:
```
db.carts.createIndex({ owner_id: 1, status: 1 })
db.carts.createIndex({ expires_at: 1 }, { expireAfterSeconds: 0 })
```

## Операции

- Создание корзины гостя:
    ```
    db.carts.insertOne({
        owner_id: "sess_46fa191e814f19729de860ea",
        type: "quest",
        items: [],
        status: "active",
        created_at: new Date(),
        updated_at: new Date(),
        expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    })
    ```
- Создание корзины авторизованного пользователя:
    ```
    db.carts.insertOne({
        owner_id: ObjectId("46fa191e814f19729de860ea"),
        type: "user",
        items: [],
        status: "active",
        created_at: new Date(),
        updated_at: new Date(),
        expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    })
    ```
- Получение корзины:
  ```mongosh
    // Для пользователя
    db.carts.findOne({ owner_id: "sess_46fa191e814f19729de860ea", status: "active" })

    // Для гостя
    db.carts.findOne({ owner_id: "46fa191e814f19729de860ea", status: "active" })
  ```
- Добавление товара в корзину:
    ```
    db.carts.updateOne(
        {
            _id: ObjectId("17fa191e810c19729de860ea"),
            "items.product_id": { $ne: ObjectId("672a1b2c3d4e5f6a7b8c9d0e") }
        },
        {
            $push: {
            items: { product_id: ObjectId("672a1b2c3d4e5f6a7b8c9d0e"), quantity: 1 }
            },
            $set: { updated_at: new Date() }
        }
    )
    ```
- Обновление существующего товара в корзине:
    ```
    db.carts.updateOne(
        {
            _id: ObjectId("17fa191e810c19729de860ea"),
            "items.product_id": ObjectId("672a1b2c3d4e5f6a7b8c9d0e")
        },
        {
            $inc: { "items.$.quantity": 1 },
            $set: { updated_at: new Date() }
        }
    )
    ```
- Изменение статуса пользовательской корзины:
    ```
    db.carts.updateOne(
        { _id: ObjectId("17fa191e810c19729de860ea") },
        { 
            $set: { 
            status: "abandoned", 
            updated_at: new Date() 
            } 
        }
    )
    ```

## Шардирование

Характеристика коллекции:

- Высокая частота записи - добавление/удаление товаров, обновление корзин;
- Короткий жизненный цикл (TTL - 7 дней);
- Данные привязаны либо к пользователю, либо к гостю - owner_id;
- Коллекция может быть очень большой при высокой посещаемости.

Шардирование в данной ситуации позволит разделить нагрузку на чтение/запись данных по шардам.
В качестве стратегии используется хэш-шардирование по owner_id (каждая корзина уникальна по owner_id и может использоваться в качестве ключа). Такой подходи позволит:
- Равномерно распределить хранение корзин пользователей и гостей по шардам (особенно учитывая количество данных коллекции);
- Обеспечить локальность даных по пользователям - хранение корзин зарегистрированных пользователей в том же шарде что и заказы пользователя;
- Выполнять чтение за 1 запрос (сетевой), поскольку данные на одном шарде;
- Поддерживает слияние корзин - гостевая корзина и пользовательская корзина, возможно, находятся на разных шардах и она может выполняться за несколько сетевых запросов (но операция редкая).


# Выявление и устранение «горячих» шардов

## Метрики состояния шардов

Перегрузка одного из шардов произошла из-за категории "Электроника", а значит при шардировании коллекции ``products`` использовался ключ по ``category``. Ключи с низкой кардинальностью и неравномерным распределением данных могу стать причиной "горячих" шардов.

Для отслеживания состояния шардов можно настроить сбор следующих метрик:

|   | Метрика | Описание |  Порог | Комментарий |
|--|--|--|--|--|
| 1 | ``shard_cpu_utilization`` | Процент использования CPU на MongoDB-ноде | >70% на одном шарде при <30% на других | Прямой индикатор перекоса в нагрузке по CPU по шардам |
| 2 | ``shard_disk_io_utilization`` | Процент времени, в течение которого диск занят (ввод-вывод) | >80% длительное время | Стабильно высокая нагрузка на диск по сравнению с другими шардами |
| 3 | ``shard_opcounters.insert/update/query`` | Количество операций в секунду по типам | Разница >3x между шардами | Неравномерная нагрузка между шардами на уровне операций |
| 4 | ``shard_network_bytes_in/out`` | Скорость передачи данных (вход/выход) на ноду | Аномальный рост на одном шарде | Явная ассиметрия в значениях между шардами может указывать на "горячий" шард |
| 5 | ``chunk_count_per_shard`` | Количество чанков, закрепленных за каждым шардом | Отклонение > ±30% от среднего | Дисбаланс в количестве чанков по шардам.|
| 6 | ``jumbo_chunk_count`` | Количество чанков, превысивших лимит chunkSize | >0 | Количество чанков, превысивших лимит chunkSize (по умолчанию 64 МБ) и не подлежащих автоматическому разбиению. Один jimbo-чанк с category "Электроника" - прямая причина "горячего" шарда. |
| 7 | ``avg_chunk_size_bytes`` | Средний размер чанка на шард (в байтах) | >64 МБ (или близко к ``chunkSize``) | Признак "тяжёлых" чанков |
| 8 | ``shard_latency_95`` | Время выполнения операций (read/write) на каждом шарде — 95% запросов укладываются в это время | Разница >3x между шардами | Явное отличие в latency одного из шардов может являться признаком hot shard |

## Механизмы автоматического перераспределения данных

### Настройка балансировщика с увеличенной частотой проверки и агрессивной миграцией

Для того чтобы заставить балансировщик быстрее реагировать на дисбаланс:
- Включить балансировку 24/7 (если ограничена по времени);
- Уменьшить порог срабатывания: мигрировать при разнице ≥1 чанка (по умолчанию — 2 чанка для small shards, 8 — для large)
- Отключить ожидание реплик (ускоряет миграцию, но снижает durability) — только если вы используете writeConcern: { w: 1 } в приложении
- Убедиться, что балансировщик включён

Сделать это можно скриптом:

```bash
use somedb

// Включить балансировку 24/7
db.settings.updateOne(
  { _id: "balancer" },
  { $set: { 
      activeWindow: { start: "00:00", stop: "23:59" }
    } 
  },
  { upsert: true }
)

// Уменьшить порог срабатывания
db.settings.updateOne(
  { _id: "balancer" },
  { $set: { migrationThreshold: 1 } },
  { upsert: true }
)

// Отключить ожидание реплик
db.settings.updateOne(
  { _id: "balancer" },
  { $set: { secondaryThrottle: false } },
  { upsert: true }
)

// Убедиться, что балансировщик включён
sh.setBalancerState(true)
```

### Сокращение размера чанка и инициализация перераспределения

Чтобы балансировщик смог равномернее распределить чанки нужно создать больше мелких чанков.

Уменьшить максимальный размер чанка до 32 МБ (вместо 64 МБ по умолчанию):

```bash
use somedb
db.settings.updateOne(
  { _id: "chunksize" },
  { $set: { value: 32 } },
  { upsert: true }
)
```

Проверка установленного размера:
```bash
db.settings.findOne({ _id: "chunksize" })
```

Вывод:
```bash
{ "_id": "chunksize", "value": 32 }
```

Принудительно запустить балансировку (если она не активна)

```bash
sh.startBalancer()
```

Проверить, что балансировщик работает
```bash
sh.isBalancerRunning()
```

> Уменьшение ``chunkSize`` влияет только на новые чанки. Существующие крупные чанки не разобьются автоматически — их нужно разбивать вручную.

### Проверка чанков по ключу, разбиение большого чанка и перемещение на другой шард

Большие чанки могут содержать категорию "Электроника", к которой идёт много запросов и изменения коллекций. Можно выделить категорию в отдельный чанк и перенести на другой, менее загруженный, шард.

1. Поиск чанков по значению ключа

```bash
use somedb

db.chunks.find({
  ns: "somedb.products",
  "min.category": { $lte: "Электроника" },
  "max.category": { $gte: "Электроника" }
}, {
  shard: 1,
  min: 1,
  max: 1,
  jumbo: 1,
  _id: 0
})
```

Пример вывода результата выполнения скрипта:
```bash
{
  "shard": "shard1",
  "min": { "category": "Бытовая техника" },
  "max": { "category": "Книги" },
  "jumbo": true
}
```

2. Разбить большой чанк на части

```bash
use somedb

sh.splitAt("somedb.products", { category: "Бытовая техника" })
sh.splitAt("somedb.products", { category: "Электроника" })
sh.splitAt("somedb.products", { category: "Книги" })
```

После выполнения скрипта один чанк будет разбит на 3

3. Переместить часть чанков на другой шард

Этим скриптом переносим чанк с категорией "Электроника" на ``shard2``:
```bash
sh.moveChunk(
  "somedb.products",
  { category: "Электроника" },
  "shard2"
)
```

## Изменение ключа шардирования

Вариантом решения проблемы может стать отказ от шардирования по ``category`` в пользу шардирования по ``_id``. Перешардировать в MongoDB невозможно напрямую требуется выполнить несколько шагов:

1. Создать новую коллекцию с хэш-шардированием по _id
   
```bash
sh.enableSharding("somedb")
sh.shardCollection("somedb.products_new", { _id: "hashed" })
```

2. Перенос данных (в фоне, порциями)

```bash
db.products.find().forEach(doc => {
  db.products_new.insertOne(doc)
})
```

3. Замена имён коллекций

```bash
db.products.renameCollection("products_old")
db.products_new.renameCollection("products")
```
