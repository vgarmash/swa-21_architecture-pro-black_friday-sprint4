### <a name="_b7urdng99y53"></a>**Название:** Миграция на Cassandra
### <a name="_b7urdng99y53"></a>**Номер записи:** 4
### <a name="_hjk0fkfyohdk"></a>**Автор:** Дубовик Сергей Андреевич
### <a name="_hjk0fkfyohdk"></a>**Исполнитель:** Старший разрабочтик номер 4
### <a name="_uanumrh8zrui"></a>**Дата:** 02.08.2025
### <a name="_qmphm5d6rvi3"></a>**Контекст**
Во время «чёрной пятницы» интернет-магазин использовал MongoDB с шардированием на основе диапазонов (Range-Based Sharding). При резком увеличении нагрузки (50 000 запросов/сек.) возникла высокая задержка при масштабировании:
При добавлении новых шардов MongoDB полностью перераспределяла данные между всеми узлами, что вызывало просадку latency в пик нагрузки, так как система тратила ресурсы на перемещение данных.
Руководство решило перейти на БД Cassandra, чтобы обеспечить:
Высокую отказоустойчивость (leaderless‑репликация).
Быстрое горизонтальное масштабирование без полного перераспределения данных.
Равномерное распределение данных.

### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**

|**№**|**Требование**| **Описание** |
| :-: | :- | :-: |
|1| Data Consistency | Необходимо соблюсти требования консистености данных при обращении к репликам, определена максимальная задержка eventual consistency в 500 мс. Планируется достичь приемлемого уровня консистентности за счет комбинации использования Hinted Handoff, Read Repair, Anti-Entropy Repair и установки подходящего Consistency Level |
|2| Scalability | Система нуждается в повышении способности к масштабированию без временных просадок производительности и перераспределения данных, как было с mognodb. Для оптимального применения Cassandra необходимо выделить сущности, способные к равномерному распределнию и линейному масштабированию без побочных эффектов |

---
### <a name="_qmphm5d6rvi3"></a>**Решение**

|**№**|**Сущность**|**Профиль нагрузки**| **Требование к консистентности** | **Подходит ли Cassandra?** | **Обоснование**
| :-: | :-: | :- | :-: | :-: | :-: |
|1| orders | интенсивная запись, чтение реже | высокие: заказ не теряется, но допустима eventual-consistency при чтении истории | Да | Использование Cassandra в роли append-only лога, построение PK по user_id, прием платежа по QUORUM write, дублирование статуса в кэш для надежности |
|2| carts | интенсивная запись/обновление | высокие | нет | Частые update операции нерекомендуемый способ работы со столбиковыми базами данных, под оптимизацию корзины лучше подойдет кэш
|3| products | интенсивное чтение, более редкие обновления | высокие | нет | Определенные поля могут подойти под хранение в Cassandra, но запасы требуют строгой консистентности |

Модель для пользовательскх заказов
Partition Key: user_id (равномерное распределние заказов)
Clustering: order_ts (для чтение истории)
order_ts, order_no - уникальные записи по комбинации номера + времени записи

```sql
CREATE TABLE orders_by_user (
    user_id     uuid,
    order_ts    timestamp,
    order_no    text,
    geo_zone    text,
    status      text,
    total       decimal,
    items       frozen<list<frozen<item>>>,
    PRIMARY KEY ((user_id), order_ts, order_no)
) WITH CLUSTERING ORDER BY (order_ts DESC);
```

Если необходима отчетность по регионам:
```sql
CREATE TABLE orders_by_geo (
    geo_zone   text,
    bucket_day date,
    order_ts   timestamp,
    order_no   text,
    user_id    uuid,
    total      decimal,
    PRIMARY KEY ((geo_zone, bucket_day), order_ts, order_no)
);
```

## Стратегии поддержания целостности

|**№**|**Сущность**|**Запись**| **Чтение** | **Стратегия целостности** | **Обоснование**
| :-: | :-: | :- | :-: | :-: | :-: |
|1| orders_by_user | QUORUM (кворум со всех кластеров) | LOCAL_QUORUM (кворум нод в кластере)  | Read Repair + Hinted Handoff | Заказ критичен; Hinted Handoff позволяет не потерять запись; Read Repair чинит расхождения при чтении |
|2| order_by_geo | LOCAL_QUORUM (кворум нод в кластере) | ONE (от ноды любого кластера - под отчеты) | Anti-Entropy Repair (по cron, например) | Отчеты могут работать по eventual consistency |

Если рассмотреть добавление потенциальных таблиц логов или пользовательских сессии приложения, то в этом случае можно использовать TTL или Hinted Handoff (в логе главное не потерять запись, консистентность в конечном итоге с задержкой 10-15 секунд приемлема (зависит от SLA, если оговорено, либо от стандартов проекта/организации))

## Допустимые уровни согласованности

|**№**|**Операция**|**Write**| **Read** | **Обоснование**
| :-: | :-: | :- | :-: | :-: |
|1| Создание заказа | QUORUM (кворум со всех кластеров) | - | Точность критически важна |
|2| Обновить статус | QUORUM (кворум со всех кластеров) | LOCAL_QUORUM (кворум с локального кластера) | Чтобы избежать "двойной оплаты" |
|3| История заказов | - | LOCAL_QUORUM (коврум нод в кластере) | Допускается небольшой лаг |
