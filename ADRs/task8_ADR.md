### <a name="_b7urdng99y53"></a>**Название:** Выявление и устранение горячих шардов
### <a name="_b7urdng99y53"></a>**Номер записи:** 2
### <a name="_hjk0fkfyohdk"></a>**Автор:** Дубовик Сергей Андреевич
### <a name="_hjk0fkfyohdk"></a>**Исполнитель:** Старший разрабочтик номер 2
### <a name="_uanumrh8zrui"></a>**Дата:** 02.08.2025
### <a name="_qmphm5d6rvi3"></a>**Контекст**
Из-за категории «Электроника» произошла перегрузка одного из шардов MongoDB, так как 70% запросов приходилось именно на эти товары. Поэтому сейчас нужно разработать стратегию, как выявлять и устранять такие «горячие» шарды, а ещё предложить метрики мониторинга, чтобы в будущем можно было предотвращать такие ситуации.

### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**

|**№**|**Требование**| **Описание** |
| :-: | :- | :-: |
|1| Observability | Необходимо соблюсти свойство прозрачности системы, чтобы реагировать на инциденты проактивно. Для этого необходимо развернуть средства логирования и мониторинга: Prometheus/Grafana, написать скрипты для сбора метрик с инстансов mongodb|

---
### <a name="_qmphm5d6rvi3"></a>**Решение**

Предлагается внедрить следующие метрики в Prometheus/Grafana (с использованием экспортера метрик):
1. Количество операций чтения/записи по шарду: mongodb_mongod_op_counters_total (shard)
2. Объем возвращенных документов: mongodb_mongod_metrics_document_returned_total
3. Количество подключений к шард-реплике: mongodb_mongod_connections{shard=...}
4. Задержки записи: mongodb_mongod_mongo_durability_latency_seconds
5. Количество перемещенных чанков: mongodb_sharding_balancer_chunks_moved_total

Метрики на уровне чанка:
1. Размер чанка: chunk.size_bytes
2. Количество чтений с чанка: chunk.reads_per_sec
3. Количество записей в чанк: chunk.writes_per_sec
4. Расчётное значение активности: chunk.hot_score


Скрипты для сбора статистики чанков:
```javascript
use config
db.chunks.aggregate([
  { $group: {
    _id: "$shard",
    totalChunks: { $sum: 1 },
    avgChunkSize: { $avg: "$size" },
    docs: { $push: "$$ROOT" }
  }}
])

sh.status()
```

опрос активности и кастомный экспорт:
cat mongos.log | grep "query" | grep collection_name | awk '{print $key}' | sort | uniq -c | sort -rn

### Устранение дисбаланса

На данный момент рассматриваются варианты:

1. Перенос данных на уровне приложения. Предлагается написать программный мигратор данных, который сбалансирует чанки или выполнит решардинг, исходя из востребованности новых категорий (шардинг по "горячим категориям" и "остальным", например, отдельный шард для электроники).
Пример потенциального решения:
Фоновый планировщик (например, cron-job или background-service), который периодически:
- Собирает метрики активности чанков (chunk.hot_score, chunk.reads_per_sec, chunk.size_bytes);
- Сравнивает текущую активность шарда с медианой кластера;
- Если активность превышает порог (например, >2x медианы), — инициирует миграцию наиболее активных чанков на менее загруженные шарды с помощью sh.moveChunk();
- Оповещает Prometheus/Grafana или логирует событие.

2. Балансировка чанков вручную или через скрипт, если проблемы с чанками:

```javascript
sh.moveChunk("products", {
  sku: "XYZ123" 
}, "shard3")
```
3. Если выключен автобалансировщик:
```javascript
sh.setBalancerState(true);
```
4. Перешардирование коллекции (нерекомендуемый способ из-за потенциального downtime):
```javascript
sh.shardCollection("products", { category: 1, sku: "hashed" })
```
5. Внедрение виртуальных шардов (если опция доступна на данный момент времени):

```javascript
{
  _id: ObjectId(),
  sku: "ABC123",
  category: "Электроника",
  vshard: NumberInt(N) //N - количество виртуальных шардов 
}

sh.shardCollection("products", { vshard: 1, sku: "hashed" })

// При вставке товара:

const vshard = Math.floor(hash(category + sku) % 32);
```

Потенциальные риски виртуальных шардов:
1. Усложнение логики в приложении (нужно помнить, как вычисляется vshard).
2. Невозможность точечного запроса по sku без знания vshard.
3. Может потребоваться вторичный индекс на sku или другие поля для компенсации.

### Альтернативные решения
1. Использовать Valkey. Популярные товары из электроники отдаются из кэша, снимая нагрузку с MongoDB. Однако от решения отказались из-за сложных фильтров(комбинаторика) и ограничений RAM.
2. Пересмотр текущих шард-ключей (например, отдельные шарды под "горячие" категории). Рабочая опция с серьезными рисками потери данных и нарушения SLA по доступности. Решено отказаться из-за недостатка опыта у администратора базы данных, что делает риск неадекватно высоким.
3. Миграция на другую базу данных с более доступными механизмами масштабирования. Решение будет обсуждено на следующем архитектурном собрании.
