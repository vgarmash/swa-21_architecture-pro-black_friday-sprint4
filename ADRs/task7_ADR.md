### <a name="_b7urdng99y53"></a>**Название:** Проектирование схем коллекций для шардирования данных
### <a name="_b7urdng99y53"></a>**Номер записи:** 1
### <a name="_hjk0fkfyohdk"></a>**Автор:** Дубовик Сергей Андреевич
### <a name="_hjk0fkfyohdk"></a>**Исполнитель:** Старший разрабочтик номер 2
### <a name="_uanumrh8zrui"></a>**Дата:** 02.08.2025
### <a name="_qmphm5d6rvi3"></a>**Контекст**
На текущий момент наблюдаются проблемы с расширением существующей платформы под новые категории товаров, ситуация располагает к проведению работ по декомпозиции системы и данных, проведения шардирования ключевых сущностей для превентивного реагирования на потенциальные проблемы с производительностью

### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**

|**№**|**Требование**|
| :-: | :- |
|1| Availability. SLA планируется на уровне 99.95% |
|2| Performance. Клиент должен получить ответ не более чем за 500мс |
|3| Scalability. Проблема хранения данных должна быть решена для объемов продаж х50 от текущих  |
---
### <a name="_qmphm5d6rvi3"></a>**Решение**

Для выбора метода шардирования необходимо описать текущие схемы базы и выбрать подходящий ключ в соотвествии с требованиями:

1. Высокое распределение (кардинальность)
2. Возможность точечных запросов к конкретному шарду (без scatter gather)
3. Избегание hotspot
4. Редкоизменяемые ключи

### Cхемы:

### `products`

```javascript
{
  _id: ObjectId(),  
  sku: String, 
  name: String,
  category: String,
  price: Decimal128,
  stock: [{
      geo: String, // "ekb", "nsk", прочие регионы
      qty: Int32
  }],
  attrs: {
      color: String,
      size: String,
      //прочие поля
  },
  updated_at: Date,
  version: 1 //версия схемы под будущие изменения
}
```

### `orders`

```javascript
{
  _id: ObjectId(),
  order_no: String, //что-то вроде UTN, внешний "человекочитаемый" формат          
  user_id: ObjectId,
  created_at: Date,
  geo_zone: String,
  status: "new" | "paid" | "shipped" | "done" | "canceled",
  items: [{
      product_id: ObjectId,
      qty: Int32,
      price: Decimal128
  }],
  total: Decimal128,
  version: 1 //версия схемы под будущие изменения
}
```

### `carts`

```javascript
{
  _id: ObjectId(),
  owner_key: String,// user_id или session_id
  owner_type: "user" | "guest",
  status: "active" | "ordered" | "abandoned",
  items: [{ product_id: ObjectId, quantity: Int32 }],
  created_at: Date,
  updated_at: Date,
  expires_at: Date, // TTL‑индекс, например, если будем хранить в кэше
  version: 1 //версия схемы под будущие изменения
}
```
---
### Ключи шардирования
| **Коллекция**  | **Шард‑ключ**| **Тип шардирования**  | **Причина** |
| :-: | :- | :-: | :-: |
| Products   | sku  | hashed | Наиболее подходящий кандидат для шардинга за счет уникальности, обновление склада идет по sku, поэтому решается проблема scatter gather |
| Orders | user_id | hashed  | Частые операции, связанные с поиском заказа пользователем идут по user-id, поле высоко-кардинальное. Если необходим поиск по продажам в регионах (если такое есть в контексте), то можно попробовать geo_zone индекс + zone sharding. |
| Carts | owner_key | hashed | Методом исключений и выбором высокой кардинальности: даты неподходят, status и owner_type тоже по причине низкой кардинальности -> неравномерного распределния, из высококардинального остается owner_key (user_id/session_id) |

### Команды

sh.enableSharding("somedb")

//Продукты/Товары
sh.shardCollection("somedb.products", { sku: "hashed" })

//Заказы
sh.shardCollection("somedb.orders", { user_id: "hashed" })

Если необходимо работать с регионами, то:

sh.addShardTag("shard1", "ekb")
sh.addShardTag("shard2", "nsk")

sh.addTagRange(
  "mobile_store.orders",
  { geo_zone: "ekb", user_id: MinKey },
  { geo_zone: "ekb", user_id: MaxKey },
  "ekb"
)

sh.addTagRange(
  "mobile_store.orders",
  { geo_zone: "nsk", user_id: MinKey },
  { geo_zone: "nsk", user_id: MaxKey },
  "nsk"
)

//Корзина
sh.shardCollection("somedb.carts", { owner_key: "hashed" })

**Альтернативы**
Range-шардирование было исключено из-за специфики работы с таблицами и данных (так же были отклонены все варианты шардирования по временным диапазонам в связи с низкой кардинальностью и неравномерным распределением).
На данный момент отклонен вариант с зонированием (шардированием по зонам заказов) в связи с отсутсвием необходимости формирования отчетности и прочих аналитических запросов по геозонам, т.к. требуется только сводные отчеты по всей организации.

**Недостатки, ограничения, риски**

1. Поиск в диапазоне цен по определенной категории может обойти все шарды (можно попробовать смягчить через кэш или программный слой, следящий за шардами).
2. Зональное шардирование требует дополнительного администрирования при расширении на новые регионы
3. Hashed‑ключ затрудняет range‑агрегации без дополнительного индексирования.